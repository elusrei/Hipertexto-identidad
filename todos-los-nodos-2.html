<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todos los Nodos - Visualización Temática Sensorial</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            text-decoration: none;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        .info-panel h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #node-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">Volver al Inicio</a>
    
    <div class="info-panel">
        <h2>Todos los Nodos</h2>
        <p>Visualización de nodos temáticos sensoriales. Haz clic en los nodos para navegar hacia las diferentes experiencias sensoriales. Los nodos grises te llevan al centro.</p>
    </div>

    <div id="node-info">Mueve el cursor sobre un nodo para ver información</div>

    <script>
        // Configuración general
        const TOTAL_NODES = 800;
        const NODES_PER_PATH = 30; // 30 nodos por cada camino sensorial
        const NEUTRAL_NODES = TOTAL_NODES - (NODES_PER_PATH * 9); // 9 caminos en total (3 para cada nodo principal)
        
        // Variables para la cámara/vista
        let viewX = 0;
        let viewY = 0;
        let targetViewX = 0;
        let targetViewY = 0;
        let initialViewX = 0;
        let initialViewY = 0;
        
        // Variables para interacción
        let hoveredNode = null;
        let selectedNode = null;
        let selectedPath = null;
        let hoverScale = 1.0;
        let hoverTargetScale = 1.0;
        
        // Arreglos para almacenar nodos y enlaces
        const nodes = [];
        const links = [];
        
        // Variable para el elemento de información del nodo
        let nodeInfo;
        
        // Definición de los nodos principales (centrales)
        const mainNodes = [
            { name: "Arañas", id: "aranias" },
            { name: "Feliz/Motivación", id: "feliz" },
            { name: "Triste", id: "triste" }
        ];
        
        // Definición de rutas sensoriales para cada nodo principal
        const sensoryPaths = {
            aranias: [
                {
                    id: "aranias_rojo",
                    name: "Camino Rojo - Arañas",
                    textures: ["muchas_lineas", "lineas_entrecruzadas", "tela_araña"],
                    sounds: ["alarma_punzante", "zumbido_agudo", "chasquidos"],
                    words: ["peligro", "alerta", "cuidado", "advertencia", "amenaza"],
                    colors: ["#FF0000", "#CC0000", "#990000"], // Tonos de rojo
                    rhythm: "pulso_constante"
                },
                {
                    id: "aranias_verde",
                    name: "Camino Verde - Arañas",
                    textures: ["lineas_que_se_acercan", "estructuras_3d", "entramados"],
                    sounds: ["wosh_estilo_jumpscare", "susurro_acercandose", "crujidos"],
                    words: ["trampa", "emboscada", "enredo", "captura", "cazador"],
                    colors: ["#00FF00", "#00CC00", "#009900"], // Tonos de verde
                    rhythm: "iiiiiiiiiiiiiiiiiiiiiip" // Ritmo entrecortado o irregular
                },
                {
                    id: "aranias_azul",
                    name: "Camino Azul - Arañas",
                    textures: ["menos_lineas", "rotas", "endebles"],
                    sounds: ["pad_tranquilo", "ambiente_suave", "goteo"],
                    words: ["observación", "paciencia", "espera", "estrategia", "sigilo"],
                    colors: ["#0000FF", "#0000CC", "#000099"], // Tonos de azul
                    rhythm: "oscilacion_lenta"
                }
            ],
            feliz: [
                {
                    id: "feliz_rojo",
                    name: "Camino Rojo - Feliz",
                    textures: ["granulado", "vibrante", "texturado"],
                    sounds: ["paraguas", "cascabeles", "risas"],
                    words: ["éxito", "victoria", "logro", "triunfo", "celebración"],
                    colors: ["#FF9999", "#FF6666", "#FF3333"], // Rojo pastel
                    rhythm: "desvanece"
                },
                {
                    id: "feliz_verde",
                    name: "Camino Verde - Feliz",
                    textures: ["mojado", "brillante", "fluido"],
                    sounds: ["estadio", "multitud", "aplausos"],
                    words: ["energía", "vitalidad", "fuerza", "poder", "impulso"],
                    colors: ["#99FF99", "#66FF66", "#33FF33"], // Verde pastel
                    rhythm: "constante"
                },
                {
                    id: "feliz_azul",
                    name: "Camino Azul - Feliz",
                    textures: ["amarillo", "dorado", "luminoso"],
                    sounds: ["melodía", "armónico", "musical"],
                    words: ["calma", "serenidad", "paz", "tranquilidad", "armonía"],
                    colors: ["#9999FF", "#6666FF", "#3333FF"], // Azul pastel
                    rhythm: "continuo_suave"
                }
            ],
            triste: [
                {
                    id: "triste_rojo",
                    name: "Camino Rojo - Triste",
                    textures: ["liso_y_frio", "plano", "simple"],
                    sounds: ["lento_y_constante", "monótono", "grave"],
                    words: ["pérdida", "ausencia", "vacío", "soledad", "abandono"],
                    colors: ["#CC9999", "#BB7777", "#AA5555"], // Rojo apagado
                    rhythm: "muy_lento"
                },
                {
                    id: "triste_verde",
                    name: "Camino Verde - Triste",
                    textures: ["humeda", "fría", "brumosa"],
                    sounds: ["llanto", "lamento", "suspiro"],
                    words: ["melancolía", "nostalgia", "añoranza", "tristeza", "recuerdo"],
                    colors: ["#99CC99", "#77BB77", "#55AA55"], // Verde apagado
                    rhythm: "gotas_espaciadas"
                },
                {
                    id: "triste_azul",
                    name: "Camino Azul - Triste",
                    textures: ["pegajosa", "viscosa", "densa"],
                    sounds: ["nostalgia", "eco", "distante"],
                    words: ["resignación", "aceptación", "rendición", "final", "despedida"],
                    colors: ["#9999CC", "#7777BB", "#5555AA"], // Azul apagado
                    rhythm: "apagandose"
                }
            ]
        };
        
        // Variables para almacenar precargas de imágenes
        let textureImages = {};
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1);
            
            // Inicializar offset de ruido
            let noiseOffset = random(1000);
            
            // Crear texturas
            createTextures();
            
            // Definir el centro del mundo
            const worldWidth = width * 4;
            const worldHeight = height * 4;
            
            // Posicionar los nodos principales
            const mainPositions = [
                { x: worldWidth * 0.25, y: worldHeight * 0.25 }, // Arañas
                { x: worldWidth * 0.75, y: worldHeight * 0.25 }, // Feliz
                { x: worldWidth * 0.5, y: worldHeight * 0.75 }   // Triste
            ];
            
            // Establecer el centro del mundo como posición inicial
            initialViewX = worldWidth * 0.5;
            initialViewY = worldHeight * 0.5;
            
            // Centrar la vista inicialmente
            targetViewX = initialViewX;
            targetViewY = initialViewY;
            
            // Crear nodos principales
            for (let i = 0; i < mainNodes.length; i++) {
                const mainNode = mainNodes[i];
                const pos = mainPositions[i];
                
                // Crear nodo principal
                nodes.push({
                    x: pos.x,
                    y: pos.y,
                    baseX: pos.x,
                    baseY: pos.y,
                    vx: 0,
                    vy: 0,
                    radius: 40, // Nodos principales más grandes
                    color: color(220, 220, 220), // Color neutral
                    nodeType: "main",
                    mainId: mainNode.id,
                    name: mainNode.name,
                    noiseOffsetX: random(1000),
                    noiseOffsetY: random(1000),
                    noiseScale: 0.01,
                    screenX: 0,
                    screenY: 0,
                    visible: true,
                    labelOpacity: 0,
                    scale: 1.0,
                    targetScale: 1.0,
                    pulseOffset: random(TWO_PI),
                    texture: null, // Sin textura específica
                    sound: null,  // Sin sonido específico
                    word: mainNode.name, // La palabra es el nombre del nodo
                    rhythm: "neutral"
                });
            }
            
            // Crear nodos para cada ruta sensorial
            let nodeCount = mainNodes.length; // Empezamos después de los nodos principales
            
            // Para cada nodo principal
            for (const mainNodeId of Object.keys(sensoryPaths)) {
                const paths = sensoryPaths[mainNodeId];
                
                // Para cada ruta sensorial de este nodo principal
                for (const path of paths) {
                    // Encontrar el nodo principal correspondiente
                    const mainNodeIndex = nodes.findIndex(n => n.mainId === mainNodeId);
                    if (mainNodeIndex === -1) continue;
                    
                    const mainNodePos = {
                        x: nodes[mainNodeIndex].x,
                        y: nodes[mainNodeIndex].y
                    };
                    
                    // Determinar la dirección de esta ruta desde el nodo principal
                    // Distribuimos las rutas en diferentes direcciones
                    const pathAngle = paths.indexOf(path) * (TWO_PI / paths.length);
                    const pathDirX = cos(pathAngle);
                    const pathDirY = sin(pathAngle);
                    
                    // Crear nodos para esta ruta sensorial
                    for (let i = 0; i < NODES_PER_PATH; i++) {
                        // Calcular distancia desde el centro (más nodos lejos del centro)
                        const distanceFactor = pow(i / NODES_PER_PATH, 0.8); // Distribución para alejar nodos
                        const maxDistance = min(width, height) * 2.5;
                        const distance = distanceFactor * maxDistance;
                        
                        // Añadir algo de variación al ángulo para no tener líneas perfectas
                        const angleVariation = random(-0.2, 0.2);
                        const angle = pathAngle + angleVariation;
                        
                        // Posición basada en dirección y distancia desde el nodo principal
                        const x = mainNodePos.x + cos(angle) * distance;
                        const y = mainNodePos.y + sin(angle) * distance;
                        
                        // Seleccionar características sensoriales para este nodo
                        // Distribuir características a lo largo de la ruta
                        const sectionIndex = floor(i / (NODES_PER_PATH / 3));
                        
                        // Seleccionar textura, sonido, palabra y color basados en la ruta
                        const texture = path.textures[min(sectionIndex, path.textures.length - 1)];
                        const nodeSound = path.sounds[min(sectionIndex, path.sounds.length - 1)];
                        const word = path.words[floor(random(path.words.length))];
                        const nodeColor = path.colors[min(sectionIndex, path.colors.length - 1)];
                        
                        // Crear nodo
                        nodes.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y,
                            vx: 0,
                            vy: 0,
                            radius: random(12, 18), // Tamaño variable
                            color: color(nodeColor),
                            nodeType: "sensory",
                            pathId: path.id, // ID de la ruta sensorial
                            mainNodeId: mainNodeId, // ID del nodo principal al que pertenece
                            name: `${path.name} - Nodo ${i+1}`,
                            noiseOffsetX: random(1000),
                            noiseOffsetY: random(1000),
                            noiseScale: random(0.01, 0.03),
                            screenX: 0,
                            screenY: 0,
                            visible: true,
                            labelOpacity: 0,
                            scale: 1.0,
                            targetScale: 1.0,
                            pulseOffset: random(TWO_PI),
                            texture: texture,
                            sound: nodeSound,
                            word: word,
                            rhythm: path.rhythm,
                            pathColor: nodeColor, // Guardar el color original de la ruta
                            pathDistance: distance, // Guardar la distancia para referencias
                            sectionIndex: sectionIndex // Índice de sección para referencias
                        });
                        
                        nodeCount++;
                    }
                }
            }
            
            // Crear nodos neutros (grises)
            for (let i = 0; i < NEUTRAL_NODES; i++) {
                // Distribución en un área 4 veces más grande que la pantalla
                const x = random(0, width * 4);
                const y = random(0, height * 4);
                
                // Color gris con variación
                const grayValue = random(100, 180);
                const nodeColor = color(grayValue, grayValue, grayValue, 180);
                
                // Crear nodo neutro
                nodes.push({
                    x: x,
                    y: y,
                    baseX: x,
                    baseY: y,
                    vx: 0,
                    vy: 0,
                    radius: random(5, 12), // Más pequeños que los temáticos
                    color: nodeColor,
                    nodeType: "neutral",
                    name: `Nodo Neutral ${i+1}`,
                    noiseOffsetX: random(1000),
                    noiseOffsetY: random(1000),
                    noiseScale: random(0.01, 0.02),
                    screenX: 0,
                    screenY: 0,
                    visible: true,
                    labelOpacity: 0,
                    scale: 1.0,
                    targetScale: 1.0,
                    pulseOffset: random(TWO_PI),
                    texture: null,
                    sound: null,
                    word: "neutral",
                    rhythm: "neutral"
                });
            }
            
            // Crear enlaces entre nodos
            createLinks();
            
            // Obtener el elemento para mostrar información del nodo
            nodeInfo = select('#node-info');
        }
        
        // Función para crear texturas
        function createTextures() {
            // Crear imágenes para texturas
            // Arañas - Rojo
            textureImages.muchas_lineas = createTextureImage("muchas_lineas", "#FF0000");
            textureImages.lineas_entrecruzadas = createTextureImage("lineas_entrecruzadas", "#FF3333");
            textureImages.tela_araña = createTextureImage("tela_araña", "#FF6666");
            
            // Arañas - Verde
            textureImages.lineas_que_se_acercan = createTextureImage("lineas_acercan", "#00FF00");
            textureImages.estructuras_3d = createTextureImage("estructuras_3d", "#33FF33");
            textureImages.entramados = createTextureImage("entramados", "#66FF66");
            
            // Arañas - Azul
            textureImages.menos_lineas = createTextureImage("menos_lineas", "#0000FF");
            textureImages.rotas = createTextureImage("rotas", "#3333FF");
            textureImages.endebles = createTextureImage("endebles", "#6666FF");
            
            // Feliz - Rojo
            textureImages.granulado = createTextureImage("granulado", "#FF9999");
            textureImages.vibrante = createTextureImage("vibrante", "#FF6666");
            textureImages.texturado = createTextureImage("texturado", "#FF3333");
            
            // Feliz - Verde
            textureImages.mojado = createTextureImage("mojado", "#99FF99");
            textureImages.brillante = createTextureImage("brillante", "#66FF66");
            textureImages.fluido = createTextureImage("fluido", "#33FF33");
            
            // Feliz - Azul
            textureImages.amarillo = createTextureImage("amarillo", "#FFFF00");
            textureImages.dorado = createTextureImage("dorado", "#FFD700");
            textureImages.luminoso = createTextureImage("luminoso", "#FFFFCC");
            
            // Triste - Rojo
            textureImages.liso_y_frio = createTextureImage("liso_frio", "#CC9999");
            textureImages.plano = createTextureImage("plano", "#BB7777");
            textureImages.simple = createTextureImage("simple", "#AA5555");
            
            // Triste - Verde
            textureImages.humeda = createTextureImage("humeda", "#99CC99");
            textureImages.fría = createTextureImage("fria", "#77BB77");
            textureImages.brumosa = createTextureImage("brumosa", "#55AA55");
            
            // Triste - Azul
            textureImages.pegajosa = createTextureImage("pegajosa", "#9999CC");
            textureImages.viscosa = createTextureImage("viscosa", "#7777BB");
            textureImages.densa = createTextureImage("densa", "#5555AA");
        }
        
        // Función auxiliar para crear imágenes de textura
        function createTextureImage(name, baseColor) {
            // En una implementación real, cargarías imágenes reales
            // Esta es una función placeholder que crea una imagen con un patrón básico
            const img = createGraphics(100, 100);
            img.background(baseColor);
            
            // Dibujar un patrón básico basado en el nombre
            img.stroke(255, 100);
            img.strokeWeight(2);
            
            if (name.includes("lineas")) {
                // Dibujar varias líneas
                const numLines = name.includes("muchas") ? 20 : (name.includes("menos") ? 5 : 10);
                for (let i = 0; i < numLines; i++) {
                    img.line(
                        random(100), random(100),
                        random(100), random(100)
                    );
                }
            } else if (name.includes("entrecruzadas") || name.includes("tela") || name.includes("entramados")) {
                // Dibujar líneas entrecruzadas
                for (let i = 0; i < 10; i++) {
                    img.line(0, i * 10, 100, 100 - i * 10);
                    img.line(i * 10, 0, 100 - i * 10, 100);
                }
            } else if (name.includes("3d") || name.includes("estructuras")) {
                // Dibujar formas que sugieran 3D
                img.push();
                img.noFill();
                for (let i = 0; i < 5; i++) {
                    img.rect(20 + i * 5, 20 + i * 5, 60 - i * 10, 60 - i * 10);
                }
                img.pop();
            } else if (name.includes("granulado") || name.includes("texturado")) {
                // Dibujar puntos para textura granulada
                img.stroke(255, 150);
                img.strokeWeight(1);
                for (let i = 0; i < 200; i++) {
                    img.point(random(100), random(100));
                }
            } else if (name.includes("liso") || name.includes("plano") || name.includes("simple")) {
                // Superficies más limpias con pocas líneas
                img.stroke(255, 50);
                img.line(0, 25, 100, 25);
                img.line(0, 50, 100, 50);
                img.line(0, 75, 100, 75);
            } else if (name.includes("mojado") || name.includes("fluido") || name.includes("humeda")) {
                // Textura que sugiere humedad
                img.noStroke();
                img.fill(255, 100);
                for (let i = 0; i < 20; i++) {
                    const size = random(5, 15);
                    img.ellipse(random(100), random(100), size, size);
                }
            } else {
                // Textura genérica para otros casos
                img.stroke(255, 120);
                for (let i = 0; i < 8; i++) {
                    img.line(0, i * 12, 100, i * 12);
                    img.line(i * 12, 0, i * 12, 100);
                }
            }
            
            return img;
        }
        
        function createLinks() {
            // Crear enlaces entre nodos de la misma ruta sensorial
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "sensory") {
                    const pathId = nodes[i].pathId;
                    
                    // Buscar otros nodos de la misma ruta sensorial
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "sensory" && nodes[j].pathId === pathId) {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con cierta probabilidad
                            const maxDist = min(width, height) * 0.8;
                            if (dist < maxDist && random() < (1 - dist/maxDist) * 0.4) {
                                // Crear enlace con el color de la ruta
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: pathId,
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 4))
                                    ),
                                    velocities: Array(floor(random(1, 4))).fill().map(() => ({
                                        x: random(-0.1, 0.1),
                                        y: random(-0.1, 0.1)
                                    })),
                                    color: nodes[i].color,
                                    opacity: random(0.5, 0.8),
                                    pulseRate: random(0.001, 0.005),
                                    pulseAmount: random(0.1, 0.3)
                                });
                            }
                        }
                    }
                    
                    // Conectar con el nodo principal correspondiente
                    const mainNodeIndex = nodes.findIndex(n => n.mainId === nodes[i].mainNodeId && n.nodeType === "main");
                    if (mainNodeIndex !== -1 && nodes[i].pathDistance < min(width, height) * 0.5) {
                        links.push({
                            source: i,
                            target: mainNodeIndex,
                            pathId: pathId,
                            points: generateIntermediatePoints2D(
                                nodes[i].x, nodes[i].y,
                                nodes[mainNodeIndex].x, nodes[mainNodeIndex].y,
                                floor(random(1, 3))
                            ),
                            velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                x: random(-0.1, 0.1),
                                y: random(-0.1, 0.1)
                            })),
                            color: nodes[i].color,
                            opacity: random(0.4, 0.7),
                            pulseRate: random(0.001, 0.004),
                            pulseAmount: random(0.1, 0.25)
                        });
                    }
                }
            }
            
            // Crear algunos enlaces entre nodos neutros
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "neutral") {
                    // Buscar otros nodos neutros cercanos
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "neutral") {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con baja probabilidad
                            const maxDist = min(width, height) * 0.4;
                            if (dist < maxDist && random() < 0.06) {
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: "neutral",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 2))
                                    ),
                                    velocities: Array(floor(random(1, 2))).fill().map(() => ({
                                        x: random(-0.05, 0.05),
                                        y: random(-0.05, 0.05)
                                    })),
                                    color: color(150, 150, 150, 100),
                                    opacity: random(0.2, 0.4),
                                    pulseRate: random(0.001, 0.002),
                                    pulseAmount: random(0.05, 0.1)
                                });
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            background(0);
            
            // Incrementar tiempo global
            let globalTime = frameCount * 0.01;
            
            // Actualizar posición de la vista con suavizado
            viewX = lerp(viewX, targetViewX, 0.05);
            viewY = lerp(viewY, targetViewY, 0.05);
            
            // Aplicar transformación para la vista
            translate(width/2 - viewX, height/2 - viewY);
            
            // Actualizar posiciones en pantalla de los nodos
            updateScreenPositions();
            
            // Verificar si el mouse está sobre algún nodo
            checkMouseOverNodes();
            
            // Dibujar enlaces
            drawLinks(globalTime);
            
            // Dibujar nodos
            drawNodes(globalTime);
            
            // Actualizar posiciones de los nodos con movimiento orgánico
            updateNodePositions();
            
            // Si hay una ruta seleccionada, reforzar su presencia
            if (selectedPath) {
                emphasizeSelectedPath();
            }
            
            // Información en pantalla (fuera de la transformación)
            resetMatrix();
            updateNodeInfo();
        }
        
        function emphasizeSelectedPath() {
            // Hacer más visibles los nodos de la ruta seleccionada
            // y menos visibles los demás
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.nodeType === "sensory") {
                    if (node.pathId === selectedPath) {
                        // Aumentar tamaño y brillo de los nodos de la ruta seleccionada
                        node.targetScale = 1.2;
                        // Reforzar color original
                        node.color = color(
                            red(node.pathColor),
                            green(node.pathColor),
                            blue(node.pathColor),
                            230
                        );
                    } else {
                        // Disminuir tamaño y opacidad de los nodos de otras rutas
                        node.targetScale = 0.7;
                        // Atenuar color
                        node.color = color(
                            red(node.pathColor) * 0.7,
                            green(node.pathColor) * 0.7,
                            blue(node.pathColor) * 0.7,
                            100
                        );
                    }
                } else if (node.nodeType === "neutral") {
                    // Atenuar nodos neutros aún más
                    node.targetScale = 0.5;
                    node.color = color(100, 100, 100, 80);
                }
            }
            
            // Ajustar visibilidad de enlaces
            for (let link of links) {
                if (link.pathId === selectedPath) {
                    link.opacity = random(0.7, 0.9); // Más visibles
                    link.pulseAmount = random(0.2, 0.4); // Más pulsación
                } else if (link.pathId !== "neutral") {
                    link.opacity = random(0.1, 0.3); // Menos visibles
                    link.pulseAmount = random(0.05, 0.1); // Menos pulsación
                } else {
                    link.opacity = random(0.05, 0.15); // Casi invisibles
                }
            }
        }
        
        function drawLinks(globalTime) {
            for (const link of links) {
                const source = nodes[link.source];
                const target = nodes[link.target];
                
                // Solo dibujar si ambos nodos son visibles
                if (source.visible && target.visible) {
                    // Calcular opacidad con efecto de pulso
                    const pulseEffect = sin(globalTime * link.pulseRate * TWO_PI) * link.pulseAmount + 1;
                    const currentOpacity = link.opacity * pulseEffect;
                    
                    // Establecer color y opacidad
                    stroke(
                        red(link.color), 
                        green(link.color), 
                        blue(link.color), 
                        alpha(link.color) * currentOpacity
                    );
                    strokeWeight(1);
                    
                    // Dibujar línea orgánica
                    drawOrganicLine2D(
                        source.x, source.y,
                        target.x, target.y,
                        link.points
                    );
                    
                    // Actualizar posiciones de los puntos intermedios
                    updateLinkPoints(link);
                }
            }
        }
        
        function drawNodes(globalTime) {
            noStroke();
            
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                if (node.visible) {
                    // Actualizar escala con suavizado
                    node.scale = lerp(node.scale, node.targetScale, 0.2);
                    
                    // Efecto de pulso basado en el ritmo del nodo
                    let pulseEffect = 1.0;
                    
                    if (node.rhythm === "pulso_constante") {
                        // Pulso regular y constante
                        pulseEffect = sin(globalTime * 2 + node.pulseOffset) * 0.15 + 1;
                    } else if (node.rhythm === "iiiiiiiiiiiiiiiiiiiiiip") {
                        // Pulso irregular entrecortado
                        pulseEffect = noise(globalTime + node.pulseOffset) * 0.3 + 0.85;
                    } else if (node.rhythm === "oscilacion_lenta") {
                        // Oscilación suave y lenta
                        pulseEffect = sin(globalTime * 0.5 + node.pulseOffset) * 0.1 + 1;
                    } else if (node.rhythm === "desvanece") {
                        // Desvanecimiento y reaparición
                        pulseEffect = abs(sin(globalTime * 0.3 + node.pulseOffset)) * 0.5 + 0.7;
                    } else if (node.rhythm === "constante") {
                        // Sin apenas variación
                        pulseEffect = 1.0 + sin(globalTime * 0.1 + node.pulseOffset) * 0.05;
                    } else {
                        // Nodos sin ritmo específico
                        pulseEffect = sin(globalTime * 0.5 + node.pulseOffset) * 0.05 + 1;
                    }
                    
                    const currentScale = node.scale * pulseEffect;
                    
                    // Si el nodo tiene textura, usarla como patrón
                    if (node.texture && textureImages[node.texture]) {
                        // Dibujar imagen de textura como fondo del nodo
                        const textureImg = textureImages[node.texture];
                        push();
                        imageMode(CENTER);
                        
                        // Ajustar tamaño de la textura al nodo
                        const texSize = node.radius * 2 * currentScale;
                        image(textureImg, node.x, node.y, texSize, texSize);
                        pop();
                    } else {
                        // Efecto de bloom (varias capas con diferentes tamaños y opacidades)
                        for (let j = 3; j > 0; j--) {
                            // Nodo seleccionado o hover: más brillante
                            if (selectedNode === i || hoveredNode === i) {
                                fill(
                                    min(red(node.color) + 70, 255),
                                    min(green(node.color) + 70, 255),
                                    min(blue(node.color) + 70, 255),
                                    60 / j // Mayor opacidad para el bloom
                                );
                            } else {
                                fill(red(node.color), green(node.color), blue(node.color), 50 / j);
                            }
                            circle(node.x, node.y, node.radius * 2 * j * currentScale);
                        }
                        
                        // Nodo principal
                        if (selectedNode === i || hoveredNode === i) {
                            fill(
                                min(red(node.color) + 70, 255),
                                min(green(node.color) + 70, 255),
                                min(blue(node.color) + 70, 255),
                                230
                            );
                        } else {
                            fill(red(node.color), green(node.color), blue(node.color), 200);
                        }
                        circle(node.x, node.y, node.radius * 2 * currentScale);
                    }
                    
                    // Si el nodo tiene una palabra, mostrarla cuando está seleccionado o en hover
                    if (node.word && (selectedNode === i || hoveredNode === i)) {
                        fill(255, 255, 255, 230);
                        textAlign(CENTER, CENTER);
                        textSize(12);
                        // Dibujar palabra encima del nodo
                        text(node.word, node.x, node.y - node.radius * currentScale - 10);
                    }
                }
            }
        }
        
        function updateNodePositions() {
            for (let node of nodes) {
                // Calcular nuevas velocidades basadas en ruido Perlin
                const time = frameCount * 0.01;
                const noiseX = noise(node.noiseOffsetX + time) * 2 - 1;
                const noiseY = noise(node.noiseOffsetY + time) * 2 - 1;
                
                // Aplicar suavizado a los cambios de velocidad
                node.vx = lerp(node.vx, noiseX * node.noiseScale * 2, 0.02);
                node.vy = lerp(node.vy, noiseY * node.noiseScale * 2, 0.02);
                
                // Actualizar posición
                node.x += node.vx;
                node.y += node.vy;
                
                // Mantener cerca de la posición base con fuerza suave
                node.x += (node.baseX - node.x) * 0.01;
                node.y += (node.baseY - node.y) * 0.01;
                
                // Actualizar escala objetivo basada en hover
                if (hoveredNode === nodes.indexOf(node)) {
                    node.targetScale = 1.3; // Agrandar al hacer hover
                } else if (selectedNode !== nodes.indexOf(node) && !selectedPath) {
                    // Solo restablecer si no hay una ruta seleccionada
                    node.targetScale = 1.0; // Tamaño normal
                }
            }
        }
        
        // Función para actualizar las posiciones de los puntos intermedios de los enlaces
        function updateLinkPoints(link) {
            if (!link.points || !link.velocities || link.points.length !== link.velocities.length) {
                return; // Evitar errores si los arrays no coinciden
            }
            
            for (let i = 0; i < link.points.length; i++) {
                const point = link.points[i];
                const velocity = link.velocities[i];
                
                // Actualizar posición con velocidad
                point.x += velocity.x;
                point.y += velocity.y;
                
                // Calcular posición base (punto en la línea recta entre origen y destino)
                const t = (i + 1) / (link.points.length + 1);
                const sourceX = nodes[link.source].x;
                const sourceY = nodes[link.source].y;
                const targetX = nodes[link.target].x;
                const targetY = nodes[link.target].y;
                
                const baseX = sourceX + (targetX - sourceX) * t;
                const baseY = sourceY + (targetY - sourceY) * t;
                
                // Mantener el punto cerca de su posición base
                point.x += (baseX - point.x) * 0.02;
                point.y += (baseY - point.y) * 0.02;
            }
        }
        
        // Función para actualizar las posiciones en pantalla de los nodos
        function updateScreenPositions() {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                // Calcular posición en pantalla
                node.screenX = node.x - viewX + width/2;
                node.screenY = node.y - viewY + height/2;
                
                // Verificar si está dentro de la pantalla (con margen)
                const margin = node.radius * 3;
                node.visible = 
                    node.screenX + margin >= 0 && 
                    node.screenX - margin <= width && 
                    node.screenY + margin >= 0 && 
                    node.screenY - margin <= height;
            }
        }
        
        // Función para verificar si el mouse está sobre algún nodo
        function checkMouseOverNodes() {
            // Resetear hover
            hoveredNode = null;
            
            // Verificar todos los nodos
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                // Solo verificar nodos visibles
                if (node.visible) {
                    const distance = dist(mouseX, mouseY, node.screenX, node.screenY);
                    
                    if (distance < node.radius * node.scale) {
                        hoveredNode = i;
                        break; // Tomar solo el primer nodo encontrado
                    }
                }
            }
        }
        
        // Función para actualizar la información del nodo
        function updateNodeInfo() {
            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                let infoText = `${node.name}`;
                
                if (node.nodeType === "main") {
                    infoText += " - Haz clic para explorar este nodo principal";
                } else if (node.nodeType === "sensory") {
                    infoText += ` - Haz clic para seguir la ruta ${node.pathId}`;
                    if (node.texture) infoText += ` | Textura: ${node.texture}`;
                    if (node.sound) infoText += ` | Sonido: ${node.sound}`;
                    if (node.word) infoText += ` | Palabra: ${node.word}`;
                } else {
                    infoText += " - Haz clic para volver al centro";
                }
                
                nodeInfo.html(infoText);
            } else {
                nodeInfo.html("Mueve el cursor sobre un nodo para ver información");
            }
        }
        
        // Función para generar puntos intermedios para líneas orgánicas en 2D
        function generateIntermediatePoints2D(x1, y1, x2, y2, numPoints) {
            const points = [];
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                
                // Línea base
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                // Vector dirección
                const dirX = x2 - x1;
                const dirY = y2 - y1;
                
                // Vector perpendicular
                const perpX = -dirY;
                const perpY = dirX;
                
                // Normalizar
                const perpLength = sqrt(perpX * perpX + perpY * perpY);
                let normPerpX = 0;
                let normPerpY = 0;
                
                if (perpLength > 0) {
                    normPerpX = perpX / perpLength;
                    normPerpY = perpY / perpLength;
                }
                
                // Aplicar desviación
                const deviation = random(-30, 30);
                
                points.push({
                    x: baseX + normPerpX * deviation,
                    y: baseY + normPerpY * deviation
                });
            }
            
            return points;
        }
        
        // Función para dibujar línea orgánica/quebrada en 2D
        function drawOrganicLine2D(x1, y1, x2, y2, points) {
            noFill();
            beginShape();
            vertex(x1, y1);
            
            for (const point of points) {
                vertex(point.x, point.y);
            }
            
            vertex(x2, y2);
            endShape();
        }
        
        // Función auxiliar para calcular distancia en 2D
        function distance2D(x1, y1, x2, y2) {
            return sqrt(
                (x2 - x1) * (x2 - x1) + 
                (y2 - y1) * (y2 - y1)
            );
        }
        
        // Función para manejar el clic en nodos
        function mousePressed() {
            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                
                // Si es un nodo sensorial, seleccionar su ruta
                if (node.nodeType === "sensory") {
                    selectedPath = node.pathId;
                    selectedNode = hoveredNode;
                    
                    // Navegar hacia el nodo principal correspondiente
                    const mainNodeIndex = nodes.findIndex(n => n.mainId === node.mainNodeId && n.nodeType === "main");
                    if (mainNodeIndex !== -1) {
                        targetViewX = nodes[mainNodeIndex].x;
                        targetViewY = nodes[mainNodeIndex].y;
                    }
                } 
                // Si es un nodo principal, limpiar selección y centrar vista
                else if (node.nodeType === "main") {
                    selectedPath = null;
                    selectedNode = hoveredNode;
                    
                    // Centrar vista en este nodo principal
                    targetViewX = node.x;
                    targetViewY = node.y;
                    
                    // Restablecer todos los nodos a su estado normal
                    for (let n of nodes) {
                        if (n.nodeType === "sensory") {
                            n.targetScale = 1.0;
                            n.color = color(
                                red(n.pathColor),
                                green(n.pathColor),
                                blue(n.pathColor),
                                200
                            );
                        } else if (n.nodeType === "neutral") {
                            n.targetScale = 1.0;
                            const grayValue = random(100, 180);
                            n.color = color(grayValue, grayValue, grayValue, 180);
                        }
                    }
                } 
                // Si es un nodo neutro, volver al centro
                else {
                    selectedPath = null;
                    selectedNode = null;
                    
                    // Volver al centro
                    targetViewX = initialViewX;
                    targetViewY = initialViewY;
                    
                    // Restablecer todos los nodos a su estado normal
                    for (let n of nodes) {
                        n.targetScale = 1.0;
                        if (n.nodeType === "sensory") {
                            n.color = color(
                                red(n.pathColor),
                                green(n.pathColor),
                                blue(n.pathColor),
                                200
                            );
                        }
                    }
                }
                return false; // Prevenir comportamiento predeterminado
            }
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>
