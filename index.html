<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red de Nodos - p5.js 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            cursor: default; /* Cursor por defecto */
        }
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            text-decoration: none;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        .info-panel h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #node-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    
    
    <!--<a href="index.html" class="back-button">Volver al Inicio</a>-->
    <!--
    <div class="info-panel">
        <h2>p5.js 3D (WEBGL)</h2>
        <p>Esta implementación utiliza p5.js en modo WEBGL para crear una visualización 3D. Los nodos se mueven en un espacio tridimensional y la escena rota suavemente.</p>
    </div>
    -->
    <div id="node-info">Mueve el cursor sobre un nodo para seleccionarlo</div>
    
    <script>
        // Prevenir menú contextual
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });

        // Configuración de nodos y enlaces
        const linkNodes = []; // Nodos principales (rosa)
        const networkNodes = []; // Nodos de red (celeste)
        const links = []; // Enlaces entre nodos principales
        const networkLinks = []; // Enlaces entre nodos de red

        // Páginas a las que enlazarán los nodos
        const pages = ["todos-los-nodos.html", "todos-los-nodos.html", "todos-los-nodos.html", "todos-los-nodos.html", "todos-los-nodos.html"] ;

        // Nombres de los nodos
        const nodeNames = ["encender sinapsis", "encender sinapsis", "encender sinapsis", "encender sinapsis", "encender sinapsis"];

        let selectedNode = -1;
        let rotationX = 0;
        let rotationY = 0;
        let nodeInfo;
        let cameraZ = 600; // Distancia de la cámara
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let dragVelocityX = 0;
        let dragVelocityY = 0;
        let dragDamping = 0.95; // Amortiguación del movimiento
        let autoRotationSpeed = 0.002; // Velocidad base de rotación automática
        let lastReleaseTime = 0; // Tiempo del último release del mouse
        let noiseOffset = 0; // Offset para el ruido Perlin
        let mouseProximity = []; // Array para almacenar proximidad del mouse a cada nodo
        
        // Variables para enlaces dinámicos
        let nextLinkUpdateTime = 0;
        let dynamicNetworkLinks = [];
        let particles = []; // Array para almacenar partículas que viajan entre nodos

        // Variables para la animación de transición
        let isTransitioning = false; // Estado de la transición
        let transitionStartTime = 0; // Tiempo de inicio de la transición
        let transitionDuration = 5000; // Duración de la transición en ms (aumentado a 2 segundos)
        let fadeOutDuration = 800; // Duración del desvanecimiento en ms (más rápido)
        let targetPage = ''; // Página a la que redirigir después de la transición
        let selectedNodeIndex = -1; // Índice del nodo seleccionado
        let finalNodeSize = .8; // Factor de tamaño final (1.5 veces el tamaño de la pantalla)
        let originalNodeRadius = 0; // Para guardar el tamaño original del nodo

        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            pixelDensity(1); // Para mejor rendimiento
            
            // Usar una fuente del sistema
            textFont('Arial');
            textSize(16);
            
            // Inicializar offset de ruido
            noiseOffset = random(1000);
            
            // Crear nodos principales (rosa) en posiciones 3D
            for (let i = 0; i < pages.length; i++) {
                // Crear múltiples instancias del mismo nodo (2-3 veces)
                const nodeCount = floor(random(2, 4)); // 2 o 3 instancias
                
                for (let j = 0; j < nodeCount; j++) {
                    // Posiciones mejor distribuidas en 3D
                    // Usar distribución esférica en lugar de plana
                    const phi = random(TWO_PI); // Ángulo horizontal
                    const theta = random(PI * 0.3, PI * 0.7); // Ángulo vertical más restringido
                    const radius = random(100, 220); // Radio para los nodos rosas
                    
                    // Convertir coordenadas esféricas a cartesianas
                    const baseX = radius * sin(theta) * cos(phi);
                    const baseY = radius * sin(theta) * sin(phi) * 0.6; // Aplastar un poco en Y
                    const baseZ = radius * cos(theta) * 0.8; // Aplastar un poco en Z
                    
                    // Crear un punto de referencia cercano para que el nodo "flote" alrededor
                    const noiseScale = random(0.02, 0.05); // Escala para el ruido Perlin
                    const noiseOffsetX = random(1000);
                    const noiseOffsetY = random(1000);
                    const noiseOffsetZ = random(1000);
                    
                    linkNodes.push({
                        x: baseX,
                        y: baseY,
                        z: baseZ,
                        radius: random(25, 35), // Nodos más grandes
                        color: color(225, 
                        random(30, 80), 
                        random(130, 205), 
                        200), // Rosa brillante
                        vx: 0,
                        vy: 0,
                        vz: 0,
                        page: pages[i],
                        name: nodeNames[i],
                        nodeGroup: i, // Para identificar el grupo
                        baseX: baseX, // Posición base para mantener dentro del área
                        baseY: baseY,
                        baseZ: baseZ,
                        noiseScale: noiseScale, // Escala para el ruido Perlin
                        noiseOffsetX: noiseOffsetX, // Offset para el ruido Perlin en X
                        noiseOffsetY: noiseOffsetY, // Offset para el ruido Perlin en Y
                        noiseOffsetZ: noiseOffsetZ, // Offset para el ruido Perlin en Z
                        screenX: 0, // Para rastreo de posición en pantalla
                        screenY: 0,
                        visible: true,
                        labelOpacity: 0 // Opacidad del texto
                    });
                    
                    // Inicializar array de proximidad del mouse
                    mouseProximity.push(0);
                }
            }
            
            // Crear nodos de red (celeste) - muchos más que los principales
            const networkNodeCount = 200; // Cantidad de nodos de red
            
            // Crear forma ovalada para los nodos de red con radio más grande
            for (let i = 0; i < networkNodeCount; i++) {
                // Posición en forma ovalada 3D
                const phi = random(TWO_PI);
                const theta = random(TWO_PI);
                const r = random(350, 450); // Radio del óvalo aumentado
                
                // Coordenadas esféricas a cartesianas, pero aplastadas para forma ovalada
                const x = r * cos(phi) * sin(theta);
                const y = (r * 0.5) * sin(phi) * sin(theta); // Aplastar en Y
                const z = r * cos(theta) * 0.7; // Aplastar en Z
                
                // Crear color celeste neón brillante y saturado
                const b = random(230, 255); // Componente azul dominante (aumentado el mínimo)
                const g = random(140, 190); // Componente verde medio (aumentado el mínimo)
                const ro = random(20, 40);   // Componente rojo muy bajo (reducido el rango)
                
                networkNodes.push({
                    x: x,
                    y: y,
                    z: z,
                    radius: random(3, 8), // Nodos más pequeños
                    color: color(ro, g, b, 200), // Turquesa neón brillante
                    vx: random(-0.3, 0.3),
                    vy: random(-0.3, 0.3),
                    vz: random(-0.3, 0.3),
                    originalX: x, // Para mantener la forma ovalada
                    originalY: y,
                    originalZ: z,
                    screenX: 0, // Para rastreo de posición en pantalla
                    screenY: 0,
                    visible: true
                });
            }
            
            // Crear enlaces entre nodos principales
            for (let i = 0; i < linkNodes.length; i++) {
                for (let j = i + 1; j < linkNodes.length; j++) {
                    // Solo conectar nodos de diferentes grupos
                    if (linkNodes[i].nodeGroup !== linkNodes[j].nodeGroup) {
                        // Probabilidad de conexión
                        if (random() < 0.3) {
                            links.push({
                                source: i,
                                target: j,
                                // Puntos intermedios para crear líneas quebradas/orgánicas
                                points: generateIntermediatePoints3D(
                                    linkNodes[i].x, linkNodes[i].y, linkNodes[i].z,
                                    linkNodes[j].x, linkNodes[j].y, linkNodes[j].z,
                                    floor(random(2, 5)) // 2-4 puntos intermedios
                                ),
                                // Añadir velocidades para movimiento sutil de los puntos
                                velocities: Array(floor(random(2, 5))).fill().map(() => ({
                                    x: random(-0.1, 0.1),
                                    y: random(-0.1, 0.1),
                                    z: random(-0.1, 0.1)
                                }))
                            });
                        }
                    }
                }
            }
            
            // Crear enlaces entre nodos de red (estructura rizomática) - Aumentar cantidad
            const connectionProbability = 0.05; // Aumentado de 0.03
            const maxDistance = 120; // Aumentado de 100
            
            for (let i = 0; i < networkNodes.length; i++) {
                // Cada nodo se conecta con algunos cercanos
                for (let j = 0; j < networkNodes.length; j++) {
                    if (i !== j) {
                        const dist = distance3D(
                            networkNodes[i].x, networkNodes[i].y, networkNodes[i].z,
                            networkNodes[j].x, networkNodes[j].y, networkNodes[j].z
                        );
                        
                        // Conectar solo nodos cercanos con cierta probabilidad
                        if (dist < maxDistance && random() < connectionProbability) {
                            networkLinks.push({
                                source: i,
                                target: j,
                                // Puntos intermedios para crear líneas quebradas/orgánicas
                                points: generateIntermediatePoints3D(
                                    networkNodes[i].x, networkNodes[i].y, networkNodes[i].z,
                                    networkNodes[j].x, networkNodes[j].y, networkNodes[j].z,
                                    floor(random(1, 3)) // 1-2 puntos intermedios
                                ),
                                // Añadir velocidades para movimiento sutil de los puntos
                                velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                    x: random(-0.05, 0.05),
                                    y: random(-0.05, 0.05),
                                    z: random(-0.05, 0.05)
                                })),
                                active: true, // Estado activo para enlaces que aparecen/desaparecen
                                opacity: 1 // Opacidad para fade in/out
                            });
                        }
                    }
                }
            }
            
            // Crear enlaces dinámicos adicionales que aparecerán/desaparecerán
            for (let i = 0; i < 50; i++) { // 50 enlaces dinámicos adicionales
                const sourceIndex = floor(random(networkNodes.length));
                const targetIndex = floor(random(networkNodes.length));
                
                if (sourceIndex !== targetIndex) {
                    dynamicNetworkLinks.push({
                        source: sourceIndex,
                        target: targetIndex,
                        points: generateIntermediatePoints3D(
                            networkNodes[sourceIndex].x, networkNodes[sourceIndex].y, networkNodes[sourceIndex].z,
                            networkNodes[targetIndex].x, networkNodes[targetIndex].y, networkNodes[targetIndex].z,
                            floor(random(1, 3)) // 1-2 puntos intermedios
                        ),
                        velocities: Array(floor(random(1, 3))).fill().map(() => ({
                            x: random(-0.05, 0.05),
                            y: random(-0.05, 0.05),
                            z: random(-0.05, 0.05)
                        })),
                        active: false, // Inicialmente inactivo
                        opacity: 0, // Inicialmente invisible
                        lifeTime: random(3000, 8000), // Tiempo de vida en milisegundos
                        birthTime: 0 // Se establecerá cuando se active
                    });
                }
            }
            
            // Obtener el elemento para mostrar información del nodo
            nodeInfo = select('#node-info');
            
            // Establecer tiempo para la primera actualización de enlaces dinámicos
            nextLinkUpdateTime = millis() + random(1000, 3000);
        }

        function draw() {
            background(0); // Fondo negro
            
            // Incrementar offset de ruido
            noiseOffset += 0.005;
            
            // Rotación suave de la escena
            if (!isDragging) {
                // Aplicar amortiguación a la velocidad de arrastre
                dragVelocityX *= dragDamping;
                
                // Continuar rotación con inercia
                rotationY += dragVelocityX;
                
                // Calcular tiempo desde el último release
                const timeSinceRelease = (millis() - lastReleaseTime) / 1000; // en segundos
                
                // Fade in de la rotación automática inmediatamente después de soltar
                if (timeSinceRelease > 0) {
                    // Calcular factor de fade in (0 a 1 en 2 segundos)
                    const fadeInFactor = constrain(timeSinceRelease / 2, 0, 1);
                    
                    // Aplicar rotación automática con fade in
                    rotationY += autoRotationSpeed * fadeInFactor;
                }
                
                // Mantener una ligera oscilación en X
                rotationX = 0.1 + sin(frameCount * 0.005) * 0.05; // Más sutil
            }
            
            // Limitar rotación en X para evitar giros extremos
            rotationX = constrain(rotationX, -PI/3, PI/3);
            
            // Aplicar rotación a la escena
            rotateX(rotationX);
            rotateY(rotationY);
            
            // Iluminación básica
            ambientLight(5);
            pointLight(255, 255, 255, 0, 0, 500);
            
            // Actualizar posiciones en pantalla de los nodos
            updateScreenPositions();
            
            // Verificar si el mouse está sobre algún nodo y actualizar proximidad
            checkMouseOverNodes();
            
            // Actualizar enlaces dinámicos
            updateDynamicLinks();
            
            // Actualizar y dibujar partículas
            updateAndDrawParticles();
            
            // Dibujar enlaces de red (celestes) con color turquesa neón
            if (isTransitioning) {
                const elapsedTime = millis() - transitionStartTime;
                const fadeProgress = min(elapsedTime / fadeOutDuration, 1);
                const baseOpacity = 100 * (1 - fadeProgress);
                
                for (const link of networkLinks) {
                    const source = networkNodes[link.source];
                    const target = networkNodes[link.target];
                    
                    // Solo dibujar si ambos nodos son visibles y el enlace está activo
                    if (source.visible && target.visible && link.active && baseOpacity > 0.1) {
                        stroke(20, 150, 250, baseOpacity);
                        drawOrganicLine3D(
                            source.x, source.y, source.z,
                            target.x, target.y, target.z,
                            link.points
                        );
                        updateLinkPoints(link);
                    }
                }
            } else {
                stroke(20, 150, 250, 100);
                for (const link of networkLinks) {
                    const source = networkNodes[link.source];
                    const target = networkNodes[link.target];
                    
                    if (source.visible && target.visible && link.active) {
                        drawOrganicLine3D(
                            source.x, source.y, source.z,
                            target.x, target.y, target.z,
                            link.points
                        );
                        updateLinkPoints(link);
                    }
                }
            }
            
            // Dibujar enlaces dinámicos con color turquesa neón
            if (isTransitioning) {
                const elapsedTime = millis() - transitionStartTime;
                const fadeProgress = min(elapsedTime / fadeOutDuration, 1);
                const baseOpacity = 100 * (1 - fadeProgress);
                
                for (const link of dynamicNetworkLinks) {
                    const source = networkNodes[link.source];
                    const target = networkNodes[link.target];
                    
                    if (source.visible && target.visible && link.active && baseOpacity > 0.1) {
                        stroke(20, 200, 250, baseOpacity);
                        drawOrganicLine3D(
                            source.x, source.y, source.z,
                            target.x, target.y, target.z,
                            link.points
                        );
                        updateLinkPoints(link);
                    }
                }
            } else {
                stroke(20, 200, 250, 100);
                for (const link of dynamicNetworkLinks) {
                    const source = networkNodes[link.source];
                    const target = networkNodes[link.target];
                    
                    if (source.visible && target.visible && link.active) {
                        drawOrganicLine3D(
                            source.x, source.y, source.z,
                            target.x, target.y, target.z,
                            link.points
                        );
                        updateLinkPoints(link);
                    }
                }
            }
            
            // Dibujar enlaces principales (rosas)
            if (isTransitioning) {
                const elapsedTime = millis() - transitionStartTime;
                const fadeProgress = min(elapsedTime / fadeOutDuration, 1);
                const baseOpacity = 150 * (1 - fadeProgress);
                
                for (const link of links) {
                    const source = linkNodes[link.source];
                    const target = linkNodes[link.target];
                    
                    if (source.visible && target.visible && baseOpacity > 0.1) {
                        stroke(255, 100, 200, baseOpacity);
                        drawOrganicLine3D(
                            source.x, source.y, source.z,
                            target.x, target.y, target.z,
                            link.points
                        );
                        updateLinkPoints(link);
                    }
                }
            } else {
                stroke(255, 100, 200, 150);
                for (const link of links) {
                    const source = linkNodes[link.source];
                    const target = linkNodes[link.target];
                    
                    if (source.visible && target.visible) {
                        drawOrganicLine3D(
                            source.x, source.y, source.z,
                            target.x, target.y, target.z,
                            link.points
                        );
                        updateLinkPoints(link);
                    }
                }
            }
            
            // Preparar arrays para ordenar nodos por profundidad
            let networkNodesToDraw = [];
            let linkNodesToDraw = [];
            
            // Calcular profundidad para todos los nodos
            for (let i = 0; i < networkNodes.length; i++) {
                const node = networkNodes[i];
                if (node.visible) {
                    // Calcular la profundidad (distancia a la cámara)
                    let nodeVector = createVector(node.x, node.y, node.z);
                    let rotatedVector = rotateVector(nodeVector, rotationX, rotationY);
                    let depth = rotatedVector.z - cameraZ; // Distancia a la cámara
                    
                    networkNodesToDraw.push({
                        index: i,
                        node: node,
                        depth: depth
                    });
                }
            }
            
            for (let i = 0; i < linkNodes.length; i++) {
                const node = linkNodes[i];
                if (node.visible) {
                    // Calcular la profundidad (distancia a la cámara)
                    let nodeVector = createVector(node.x, node.y, node.z);
                    let rotatedVector = rotateVector(nodeVector, rotationX, rotationY);
                    let depth = rotatedVector.z - cameraZ; // Distancia a la cámara
                    
                    // Si es el nodo seleccionado y estamos en transición, ponerlo en la capa más cercana
                    if (isTransitioning && i === selectedNodeIndex) {
                        depth = -Infinity; // Asegurar que esté en la capa más cercana
                    }
                    
                    linkNodesToDraw.push({
                        index: i,
                        node: node,
                        depth: depth
                    });
                }
            }
            
            // Ordenar nodos por profundidad (los más lejanos primero)
            networkNodesToDraw.sort((b, a) => b.depth - a.depth);
            linkNodesToDraw.sort((b, a) => b.depth - a.depth);
            
            // Encontrar la profundidad mínima y máxima de los nodos rosas
            let minPinkDepth = Infinity;
            let maxPinkDepth = -Infinity;
            
            for (const nodeToDraw of linkNodesToDraw) {
                if (nodeToDraw.depth < minPinkDepth) minPinkDepth = nodeToDraw.depth;
                if (nodeToDraw.depth > maxPinkDepth) maxPinkDepth = nodeToDraw.depth;
            }
            
            // Dividir nodos celestes en dos grupos: los que están detrás y los que están delante de los rosas
            let backNetworkNodes = networkNodesToDraw.filter(node => node.depth <= minPinkDepth);
            let frontNetworkNodes = networkNodesToDraw.filter(node => node.depth > minPinkDepth);
            
            // Dibujar nodos celestes que están DETRÁS de los nodos rosas
            noStroke();
            for (const nodeToDraw of backNetworkNodes) {
                const node = nodeToDraw.node;
                
                // Calcular opacidad basada en la transición
                let opacity = 200;
                if (isTransitioning) {
                    opacity = 200 * (1 - min((millis() - transitionStartTime) / fadeOutDuration, 1));
                }
                
                push();
                translate(node.x, node.y, node.z);
                
                // Hacer que los nodos siempre miren a la cámara
                rotateY(-rotationY);
                rotateX(-rotationX);
                
                // Efecto de bloom (varias capas con diferentes tamaños y opacidades)
                for (let j = 3; j > 0; j--) {
                    fill(
                        red(node.color), 
                        green(node.color), 
                        blue(node.color), 
                        opacity / j
                    );
                    circle(0, 0, node.radius * 2 * j);
                }
                
                // Nodo principal
                fill(
                    red(node.color), 
                    green(node.color), 
                    blue(node.color), 
                    opacity
                );
                circle(0, 0, node.radius * 2);
                
                pop();
                
                // Solo actualizar posición si no estamos en transición
                if (!isTransitioning) {
                    // Actualizar posición con movimiento suave
                    node.x += node.vx;
                    node.y += node.vy;
                    node.z += node.vz;
                    
                    // Mantener cerca de la posición original (forma ovalada)
                    node.x += (node.originalX - node.x) * 0.01;
                    node.y += (node.originalY - node.y) * 0.01;
                    node.z += (node.originalZ - node.z) * 0.01;
                }
            }
            
            // Dibujar nodos principales (rosas) con efecto de bloom en orden de profundidad
            for (const nodeToDraw of linkNodesToDraw) {
                const node = nodeToDraw.node;
                const i = nodeToDraw.index;
                
                // Si estamos en transición, solo dibujar el nodo seleccionado
                if (isTransitioning && i !== selectedNodeIndex) continue;
                
                push();
                translate(node.x, node.y, node.z);
                
                // Hacer que los nodos siempre miren a la cámara
                rotateY(-rotationY);
                rotateX(-rotationX);
                
                // Calcular opacidad basada en la transición
                let opacity = 200;
                if (isTransitioning) {
                    if (i === selectedNodeIndex) {
                        opacity = 200; // Mantener opacidad completa para el nodo seleccionado
                    } else {
                        opacity = 200 * (1 - min((millis() - transitionStartTime) / fadeOutDuration, 1));
                    }
                }
                
                // Efecto de bloom (varias capas con diferentes tamaños y opacidades)
                for (let j = 3; j > 0; j--) {
                    if (i === selectedNode) {
                        fill(
                            min(red(node.color) + 70, 255),
                            min(green(node.color) + 70, 255),
                            min(blue(node.color) + 70, 255),
                            opacity / j
                        );
                    } else {
                        fill(
                            red(node.color), 
                            green(node.color), 
                            blue(node.color), 
                            opacity / j
                        );
                    }
                    circle(0, 0, node.radius * 2 * j);
                }
                
                // Nodo principal
                if (i === selectedNode) {
                    fill(
                        min(red(node.color) + 70, 255),
                        min(green(node.color) + 70, 255),
                        min(blue(node.color) + 70, 255),
                        opacity
                    );
                } else {
                    fill(
                        red(node.color), 
                        green(node.color), 
                        blue(node.color), 
                        opacity
                    );
                }
                circle(0, 0, node.radius * 2);
                
                // Actualizar opacidad del texto basado en proximidad del mouse y transición
                node.labelOpacity = lerp(node.labelOpacity, mouseProximity[i] * (isTransitioning ? 0 : 1), 0.1);
                
                // Dibujar texto del nodo con opacidad variable
                if (node.labelOpacity > 0.01) {
                    fill(255, 255, 255, 255 * node.labelOpacity);
                    textAlign(CENTER, CENTER);
                    textSize(12);
                    // Dibujar texto encima del nodo
                    text(node.name, 0, -node.radius - 10);
                }
                
                pop();
                
                // Solo actualizar posición si no estamos en transición
                if (!isTransitioning) {
                    // Actualizar posición con movimiento orgánico basado en ruido Perlin
                    const time = frameCount * 0.01;
                    const noiseX = noise(node.noiseOffsetX + time) * 2 - 1;
                    const noiseY = noise(node.noiseOffsetY + time) * 2 - 1;
                    const noiseZ = noise(node.noiseOffsetZ + time) * 2 - 1;
                    
                    // Aplicar suavizado a los cambios de velocidad
                    node.vx = lerp(node.vx, noiseX * 0.5, 0.02);
                    node.vy = lerp(node.vy, noiseY * 0.5, 0.02);
                    node.vz = lerp(node.vz, noiseZ * 0.5, 0.02);
                    
                    // Actualizar posición
                    node.x += node.vx;
                    node.y += node.vy;
                    node.z += node.vz;
                    
                    // Mantener cerca de la posición base con fuerza suave
                    node.x += (node.baseX - node.x) * 0.01;
                    node.y += (node.baseY - node.y) * 0.01;
                    node.z += (node.baseZ - node.z) * 0.01;
                }
            }
            
            // Actualizar y dibujar la transición
            updateAndDrawTransition();
            
            // Dibujar nodos celestes que están DELANTE de los nodos rosas
            for (const nodeToDraw of frontNetworkNodes) {
                const node = nodeToDraw.node;
                
                // Calcular opacidad basada en la transición
                let opacity = 200;
                if (isTransitioning) {
                    opacity = 200 * (1 - min((millis() - transitionStartTime) / fadeOutDuration, 1));
                }
                
                push();
                translate(node.x, node.y, node.z);
                
                // Hacer que los nodos siempre miren a la cámara
                rotateY(-rotationY);
                rotateX(-rotationX);
                
                // Efecto de bloom (varias capas con diferentes tamaños y opacidades)
                for (let j = 3; j > 0; j--) {
                    fill(
                        red(node.color), 
                        green(node.color), 
                        blue(node.color), 
                        opacity / j
                    );
                    circle(0, 0, node.radius * 2 * j);
                }
                
                // Nodo principal
                fill(
                    red(node.color), 
                    green(node.color), 
                    blue(node.color), 
                    opacity
                );
                circle(0, 0, node.radius * 2);
                
                pop();
                
                // Solo actualizar posición si no estamos en transición
                if (!isTransitioning) {
                    // Actualizar posición con movimiento suave
                    node.x += node.vx;
                    node.y += node.vy;
                    node.z += node.vz;
                    
                    // Mantener cerca de la posición original (forma ovalada)
                    node.x += (node.originalX - node.x) * 0.01;
                    node.y += (node.originalY - node.y) * 0.01;
                    node.z += (node.originalZ - node.z) * 0.01;
                }
            }
            
            // Información en pantalla (fuera de la transformación 3D)
            resetMatrix();
            if (selectedNode !== -1) {
                const node = linkNodes[selectedNode];
                nodeInfo.html(`Haz clic para ${node.name}`);
            } else {
                nodeInfo.html("Selecciona un nodo con el cursor");
            }
        }

        // Función para actualizar las posiciones de los puntos intermedios de los enlaces
        function updateLinkPoints(link) {
            if (!link.points || !link.velocities || link.points.length !== link.velocities.length) {
                return; // Evitar errores si los arrays no coinciden
            }
            
            for (let i = 0; i < link.points.length; i++) {
                const point = link.points[i];
                const velocity = link.velocities[i];
                
                // Actualizar posición con velocidad
                point.x += velocity.x;
                point.y += velocity.y;
                point.z += velocity.z;
                
                // Calcular posición base (punto en la línea recta entre origen y destino)
                const t = (i + 1) / (link.points.length + 1);
                let sourceX, sourceY, sourceZ, targetX, targetY, targetZ;
                
                if (link.source < linkNodes.length && link.target < linkNodes.length) {
                    // Enlace entre nodos principales
                    sourceX = linkNodes[link.source].x;
                    sourceY = linkNodes[link.source].y;
                    sourceZ = linkNodes[link.source].z;
                    targetX = linkNodes[link.target].x;
                    targetY = linkNodes[link.target].y;
                    targetZ = linkNodes[link.target].z;
                } else {
                    // Enlace entre nodos de red
                    sourceX = networkNodes[link.source].x;
                    sourceY = networkNodes[link.source].y;
                    sourceZ = networkNodes[link.source].z;
                    targetX = networkNodes[link.target].x;
                    targetY = networkNodes[link.target].y;
                    targetZ = networkNodes[link.target].z;
                }
                
                const baseX = sourceX + (targetX - sourceX) * t;
                const baseY = sourceY + (targetY - sourceY) * t;
                const baseZ = sourceZ + (targetZ - sourceZ) * t;
                
                // Mantener el punto cerca de su posición base
                point.x += (baseX - point.x) * 0.02;
                point.y += (baseY - point.y) * 0.02;
                point.z += (baseZ - point.z) * 0.02;
            }
        }

        // Función para actualizar enlaces dinámicos
        function updateDynamicLinks() {
            const currentTime = millis();
            
            // Verificar si es tiempo de activar/desactivar un enlace
            if (currentTime > nextLinkUpdateTime) {
                // Elegir un enlace aleatorio para cambiar su estado
                const linkIndex = floor(random(dynamicNetworkLinks.length));
                const link = dynamicNetworkLinks[linkIndex];
                
                if (!link.active) {
                    // Activar el enlace
                    link.active = true;
                    link.birthTime = currentTime;
                    
                    // Regenerar puntos para una nueva forma
                    link.points = generateIntermediatePoints3D(
                        networkNodes[link.source].x, networkNodes[link.source].y, networkNodes[link.source].z,
                        networkNodes[link.target].x, networkNodes[link.target].y, networkNodes[link.target].z,
                        link.points.length
                    );
                }
                
                // Programar la próxima actualización
                nextLinkUpdateTime = currentTime + random(500, 2000);
            }
            
            // Actualizar opacidad de los enlaces dinámicos y crear nuevas partículas en conexiones duraderas
            for (const link of dynamicNetworkLinks) {
                if (link.active) {
                    const age = currentTime - link.birthTime;
                    
                    if (link.isTemporary) {
                        // Para enlaces temporarios de partículas
                        if (age > link.lifeTime) {
                            link.active = false;
                            link.opacity = 0;
                        } else if (link.isLongConnection && currentTime - link.lastParticleTime > (1/0.003) * 16.67) {
                            // Si es una conexión duradera y ha pasado suficiente tiempo desde la última partícula
                            // Crear una nueva partícula en la misma conexión
                            const newParticle = createParticle(link.source, link.target, [...link.points]);
                            particles.push(newParticle);
                            link.lastParticleTime = currentTime;
                        }
                    } else {
                        // Comportamiento normal para enlaces dinámicos regulares
                        if (age < 1000) {
                            // Fade in
                            link.opacity = age / 1000;
                        } else if (age > link.lifeTime - 1000) {
                            // Fade out
                            link.opacity = (link.lifeTime - age) / 1000;
                        } else {
                            // Completamente visible
                            link.opacity = 1;
                        }
                        
                        // Desactivar si ha superado su tiempo de vida
                        if (age > link.lifeTime) {
                            link.active = false;
                            link.opacity = 0;
                        }
                    }
                }
            }
            
            // También actualizar opacidad de los enlaces de red normales
            // Ocasionalmente hacer que algunos enlaces parpadeen
            for (const link of networkLinks) {
                if (random() < 0.001) { // Probabilidad baja para que no todos parpadeen a la vez
                    link.active = !link.active;
                    link.opacity = link.active ? 0 : 1;
                }
            }
        }

        // Función para crear una partícula que viaja entre dos nodos
        function createParticle(sourceNode, targetNode, linkPoints) {
            // Crear color celeste neón brillante para la partícula
            const b = random(230, 255); // Componente azul dominante (aumentado el mínimo)
            const g = random(180, 230); // Componente verde medio (aumentado el mínimo)
            const r = random(20, 40);   // Componente rojo muy bajo (reducido el rango)
            
            return {
                sourceNode: sourceNode,
                targetNode: targetNode,
                x: networkNodes[sourceNode].x,
                y: networkNodes[sourceNode].y,
                z: networkNodes[sourceNode].z,
                progress: 0, // 0 a 1, donde 1 es llegar al destino
                speed: random(0.001, 0.005), // Velocidad mucho más lenta y variable
                size: random(2, 4), // Tamaño más pequeño
                color: color(r, g, b, 200), // Color turquesa neón
                completed: false, // Si ha completado su recorrido
                path: linkPoints ? [...linkPoints] : [] // Copia de los puntos del enlace para seguir la misma trayectoria
            };
        }

        // Función para actualizar y dibujar partículas
        function updateAndDrawParticles() {
            // Filtrar partículas completadas
            particles = particles.filter(p => !p.completed);
            
            // Dibujar y actualizar partículas existentes
            for (let particle of particles) {
                // Actualizar progreso
                particle.progress += particle.speed;
                
                // Determinar posición actual en la trayectoria
                let currentPos = calculateParticlePosition(particle);
                particle.x = currentPos.x;
                particle.y = currentPos.y;
                particle.z = currentPos.z;
                
                // Dibujar partícula sin efecto de bloom, solo un punto simple
                push();
                translate(particle.x, particle.y, particle.z);
                
                // Hacer que la partícula siempre mire a la cámara
                rotateY(-rotationY);
                rotateX(-rotationX);
                
                // Partícula simple sin bloom
                fill(particle.color);
                circle(0, 0, particle.size);
                
                pop();
                
                // Verificar si ha llegado al destino
                if (particle.progress >= 1) {
                    particle.completed = true;
                    
                    // Solo mover un nodo ocasionalmente (30% de probabilidad)
                    if (random() < 0.3) {
                        const nodeToMove = random() < 0.5 ? particle.sourceNode : particle.targetNode;
                        
                        // Generar nueva posición con un desplazamiento sutil
                        // Mantener la forma general, solo pequeños ajustes
                        const currentNode = networkNodes[nodeToMove];
                        
                        // Calcular un desplazamiento pequeño y aleatorio
                        const offsetDistance = random(10, 30); // Desplazamiento mucho más pequeño
                        const offsetAngle1 = random(TWO_PI);
                        const offsetAngle2 = random(TWO_PI);
                        
                        // Calcular nueva posición con desplazamiento sutil
                        const newX = currentNode.originalX + cos(offsetAngle1) * sin(offsetAngle2) * offsetDistance;
                        const newY = currentNode.originalY + sin(offsetAngle1) * sin(offsetAngle2) * offsetDistance;
                        const newZ = currentNode.originalZ + cos(offsetAngle2) * offsetDistance;
                        
                        // Actualizar posición original para referencia
                        networkNodes[nodeToMove].originalX = newX;
                        networkNodes[nodeToMove].originalY = newY;
                        networkNodes[nodeToMove].originalZ = newZ;
                        
                        // Dar un impulso muy sutil en la dirección de la nueva posición
                        const dirX = newX - networkNodes[nodeToMove].x;
                        const dirY = newY - networkNodes[nodeToMove].y;
                        const dirZ = newZ - networkNodes[nodeToMove].z;
                        
                        // Normalizar y aplicar impulso sutil
                        const magnitude = sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ);
                        if (magnitude > 0) { // Evitar división por cero
                            networkNodes[nodeToMove].vx = dirX / magnitude * 0.3; // Impulso mucho más sutil
                            networkNodes[nodeToMove].vy = dirY / magnitude * 0.3;
                            networkNodes[nodeToMove].vz = dirZ / magnitude * 0.3;
                        }
                    }
                }
            }
            
            // Ocasionalmente crear nuevas partículas (reducir frecuencia)
            if (random() < 0.01) { // Probabilidad más baja
                createRandomParticle();
            }
        }

        // Función para calcular la posición actual de la partícula en su trayectoria
        function calculateParticlePosition(particle) {
            const source = networkNodes[particle.sourceNode];
            const target = networkNodes[particle.targetNode];
            
            // Si no hay puntos intermedios, interpolar directamente
            if (!particle.path || particle.path.length === 0) {
                return {
                    x: lerp(source.x, target.x, particle.progress),
                    y: lerp(source.y, target.y, particle.progress),
                    z: lerp(source.z, target.z, particle.progress)
                };
            }
            
            // Si hay puntos intermedios, determinar en qué segmento está
            const allPoints = [
                {x: source.x, y: source.y, z: source.z},
                ...particle.path,
                {x: target.x, y: target.y, z: target.z}
            ];
            
            const totalSegments = allPoints.length - 1;
            const segmentProgress = particle.progress * totalSegments;
            const currentSegment = Math.min(Math.floor(segmentProgress), totalSegments - 1);
            const segmentT = segmentProgress - currentSegment;
            
            // Interpolar entre los puntos del segmento actual
            return {
                x: lerp(allPoints[currentSegment].x, allPoints[currentSegment + 1].x, segmentT),
                y: lerp(allPoints[currentSegment].y, allPoints[currentSegment + 1].y, segmentT),
                z: lerp(allPoints[currentSegment].z, allPoints[currentSegment + 1].z, segmentT)
            };
        }

        // Función para crear una partícula aleatoria entre dos nodos de red
        function createRandomParticle() {
            // Seleccionar dos nodos aleatorios
            const sourceIndex = floor(random(networkNodes.length));
            let targetIndex;
            
            // Asegurarse de que el destino sea diferente al origen
            do {
                targetIndex = floor(random(networkNodes.length));
            } while (targetIndex === sourceIndex);
            
            // Generar puntos intermedios para la trayectoria
            const points = generateIntermediatePoints3D(
                networkNodes[sourceIndex].x, networkNodes[sourceIndex].y, networkNodes[sourceIndex].z,
                networkNodes[targetIndex].x, networkNodes[targetIndex].y, networkNodes[targetIndex].z,
                floor(random(1, 3)) // 1-2 puntos intermedios
            );
            
            // Crear la partícula
            const particle = createParticle(sourceIndex, targetIndex, points);
            particles.push(particle);
            
            // Determinar si esta conexión durará más tiempo (permitirá múltiples envíos)
            const isLongConnection = random() < 0.3; // 30% de probabilidad de ser una conexión duradera
            const connectionLifeTime = isLongConnection ? 
                (1 / particle.speed) * 16.67 * random(3, 6) : // 3-6 veces más larga para conexiones duraderas
                (1 / particle.speed) * 16.67; // Duración normal basada en la velocidad de la partícula
            
            // Crear un enlace temporal para mostrar la trayectoria
            const tempLink = {
                source: sourceIndex,
                target: targetIndex,
                points: points,
                velocities: Array(points.length).fill().map(() => ({
                    x: random(-0.02, 0.02),
                    y: random(-0.02, 0.02),
                    z: random(-0.02, 0.02)
                })),
                active: true,
                opacity: 0.4, // Opacidad más sutil
                isTemporary: true, // Marcar como enlace temporal
                birthTime: millis(),
                lifeTime: connectionLifeTime,
                isLongConnection: isLongConnection, // Marcar si es una conexión duradera
                lastParticleTime: millis() // Tiempo de la última partícula enviada
            };
            
            dynamicNetworkLinks.push(tempLink);
        }

        // Función para actualizar las posiciones en pantalla de los nodos
        function updateScreenPositions() {
            for (let node of [...linkNodes, ...networkNodes]) {
                // Crear vector para la posición del nodo
                let nodeVector = createVector(node.x, node.y, node.z);
                
                // Aplicar rotaciones de la escena
                let rotatedVector = rotateVector(nodeVector, rotationX, rotationY);
                
                // Proyectar a coordenadas de pantalla
                let screenPos = worldToScreen(rotatedVector.x, rotatedVector.y, rotatedVector.z);
                
                node.screenX = screenPos.x;
                node.screenY = screenPos.y;
                node.visible = screenPos.z < 0; // Visible si está delante de la cámara
            }
        }

        // Función para rotar un vector según los ángulos de rotación de la escena
        function rotateVector(vec, rotX, rotY) {
            // Rotar alrededor del eje Y
            let rotatedY = createVector(
                vec.x * cos(rotY) + vec.z * sin(rotY),
                vec.y,
                -vec.x * sin(rotY) + vec.z * cos(rotY)
            );
            
            // Rotar alrededor del eje X
            let rotatedXY = createVector(
                rotatedY.x,
                rotatedY.y * cos(rotX) - rotatedY.z * sin(rotX),
                rotatedY.y * sin(rotX) + rotatedY.z * cos(rotX)
            );
            
            return rotatedXY;
        }

        // Función para convertir coordenadas 3D a coordenadas de pantalla
        function worldToScreen(x, y, z) {
            // Ajustar Z para la distancia de la cámara
            let adjustedZ = z - cameraZ;
            
            // Proyección simple
            let factor = cameraZ / abs(adjustedZ);
            let screenX = width / 2 + x * factor;
            let screenY = height / 2 + y * factor;
            
            return { x: screenX, y: screenY, z: adjustedZ };
        }

        // Función para verificar si el mouse está sobre algún nodo
        function checkMouseOverNodes() {
            // Resetear selección
            selectedNode = -1;
            
            // Preparar array para ordenar nodos por profundidad
            let interactiveNodes = [];
            
            // Recopilar todos los nodos visibles con su profundidad
            for (let i = 0; i < linkNodes.length; i++) {
                const node = linkNodes[i];
                
                // Solo verificar nodos visibles
                if (node.visible) {
                    // Calcular la profundidad (distancia a la cámara)
                    let nodeVector = createVector(node.x, node.y, node.z);
                    let rotatedVector = rotateVector(nodeVector, rotationX, rotationY);
                    let depth = rotatedVector.z - cameraZ; // Distancia a la cámara
                    
                    interactiveNodes.push({
                        index: i,
                        node: node,
                        depth: -depth
                    });
                }
            }
            
            // Ordenar nodos por profundidad (los más cercanos primero, para que tengan prioridad en la interacción)
            interactiveNodes.sort((a, b) => a.depth - b.depth);
            
            // Verificar interacción en orden de cercanía
            let isOverNode = false;
            for (const nodeToDraw of interactiveNodes) {
                const node = nodeToDraw.node;
                const i = nodeToDraw.index;
                
                const distance = dist(mouseX, mouseY, node.screenX, node.screenY);
                
                // Calcular tamaño aparente basado en la distancia a la cámara
                let nodeVector = createVector(node.x, node.y, node.z);
                let rotatedVector = rotateVector(nodeVector, rotationX, rotationY);
                let distanceToCamera = abs(rotatedVector.z - cameraZ);
                let apparentSize = node.radius * (cameraZ / distanceToCamera) * 1.5; // Factor de ajuste
                
                // Calcular proximidad (1 cuando está sobre el nodo, 0 cuando está lejos)
                const proximityThreshold = apparentSize * 3; // Distancia a la que comienza a aparecer el texto
                mouseProximity[i] = constrain(1 - distance / proximityThreshold, 0, 1);
                
                // Si el mouse está sobre este nodo, seleccionarlo y detener la búsqueda
                if (distance < apparentSize) {
                    selectedNode = i;
                    isOverNode = true;
                    break; // Detener después de encontrar el primer nodo (el más cercano)
                }
            }
            
            // Cambiar el cursor según si está sobre un nodo
            if (isOverNode) {
                document.body.style.cursor = 'pointer';
                canvas.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
                canvas.style.cursor = 'default';
            }
            
            // Resetear proximidad para nodos no visibles
            for (let i = 0; i < linkNodes.length; i++) {
                if (!linkNodes[i].visible) {
                    mouseProximity[i] = 0;
                }
            }
        }

        // Función para generar puntos intermedios para líneas orgánicas en 3D
        function generateIntermediatePoints3D(x1, y1, z1, x2, y2, z2, numPoints) {
            const points = [];
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                
                // Línea base
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                const baseZ = z1 + (z2 - z1) * t;
                
                // Añadir desviación para hacerla orgánica pero más sutil
                // Crear un vector perpendicular aleatorio
                
                const dirX = x2 - x1;
                const dirY = y2 - y1;
                const dirZ = z2 - z1;
                
                // Vector perpendicular aleatorio
                let perpX, perpY, perpZ;
                
                // Generar vector perpendicular
                if (abs(dirY) > 0.1 || abs(dirZ) > 0.1) {
                    perpX = 0;
                    perpY = -dirZ;
                    perpZ = dirY;
                } else {
                    perpX = -dirZ;
                    perpY = 0;
                    perpZ = dirX;
                }
                
                // Normalizar
                const perpLength = sqrt(perpX * perpX + perpY * perpY + perpZ * perpZ);
                perpX /= perpLength;
                perpY /= perpLength;
                perpZ /= perpLength;
                
                // Aplicar desviación más sutil
                const deviation = random(-25, 25);
                
                points.push({
                    x: baseX + perpX * deviation,
                    y: baseY + perpY * deviation,
                    z: baseZ + perpZ * deviation
                });
            }
            
            return points;
        }

        // Función para dibujar línea orgánica/quebrada en 3D
        function drawOrganicLine3D(x1, y1, z1, x2, y2, z2, points) {
            noFill(); // Asegurar que no haya relleno
            beginShape();
            vertex(x1, y1, z1);
            
            for (const point of points) {
                vertex(point.x, point.y, point.z);
            }
            
            vertex(x2, y2, z2);
            endShape();
        }

        // Función auxiliar para calcular distancia en 3D
        function distance3D(x1, y1, z1, x2, y2, z2) {
            return sqrt(
                (x2 - x1) * (x2 - x1) + 
                (y2 - y1) * (y2 - y1) + 
                (z2 - z1) * (z2 - z1)
            );
        }

        // Función para actualizar y dibujar la transición
        function updateAndDrawTransition() {
            if (!isTransitioning) return;
            
            const currentTime = millis();
            const elapsedTime = currentTime - transitionStartTime;
            const progress = elapsedTime / transitionDuration;
            const fadeProgress = min(elapsedTime / fadeOutDuration, 1); // Progreso del desvanecimiento
            
            if (progress >= 1) {
                // La transición ha terminado
                isTransitioning = false;
                // Restaurar tamaño original del nodo
                if (selectedNodeIndex !== -1) {
                    linkNodes[selectedNodeIndex].radius = originalNodeRadius;
                }
                // Redirigir a la página objetivo
                window.location.href = targetPage;
                return;
            }
            
            // Calcular el tamaño del nodo seleccionado con una curva de crecimiento más lenta
            const maxSize = max(width, height) * finalNodeSize; // Tamaño máximo ajustable
            const selectedNode = linkNodes[selectedNodeIndex];
            
            // Función de easing personalizada: más lenta al principio, más rápida al final
            const growthProgress = progress < 0.5 
                ? 2 * progress * progress // Más lento al principio
                : 1 - Math.pow(-2 * progress + 2, 2) / 2; // Más rápido al final
            
            const nodeSize = lerp(originalNodeRadius * 2, maxSize, growthProgress);
            
            // Actualizar el radio del nodo
            selectedNode.radius = nodeSize / 2;
            
            // Dibujar el nodo seleccionado expandiéndose
            push();
            translate(selectedNode.x, selectedNode.y, selectedNode.z);
            rotateY(-rotationY);
            rotateX(-rotationX);
            
            // Efecto de brillo para el nodo expandido
            for (let j = 3; j > 0; j--) {
                fill(
                    red(selectedNode.color),
                    green(selectedNode.color),
                    blue(selectedNode.color),
                    200 / j
                );
                circle(0, 0, nodeSize * j);
            }
            
            // Nodo principal expandido
            fill(
                red(selectedNode.color),
                green(selectedNode.color),
                blue(selectedNode.color),
                200
            );
            circle(0, 0, nodeSize);
            
            pop();
        }

        function mousePressed() {
            if (selectedNode !== -1) {
                const node = linkNodes[selectedNode];
                // Guardar tamaño original del nodo
                originalNodeRadius = node.radius;
                // Iniciar transición
                isTransitioning = true;
                transitionStartTime = millis();
                targetPage = node.page;
                selectedNodeIndex = selectedNode;
            } else {
                isDragging = true;
                previousMouseX = mouseX;
                previousMouseY = mouseY;
            }
        }
        
        function mouseDragged() {
            if (isDragging) {
                // Calcular velocidad de arrastre (solo en el eje Y)
                dragVelocityX = (mouseX - previousMouseX) * 0.01;
                
                // Actualizar rotación (solo en el eje Y)
                rotationY += dragVelocityX;
                
                previousMouseX = mouseX;
                previousMouseY = mouseY;
                
                return false; // Prevenir comportamiento predeterminado
            }
        }
        
        function mouseReleased() {
            if (isDragging) {
                isDragging = false;
                lastReleaseTime = millis(); // Registrar el tiempo de liberación
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>
