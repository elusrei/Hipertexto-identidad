<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todos los Nodos - Visualización Temática Sensorial</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            text-decoration: none;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        .info-panel h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #node-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #path-counters {
            position: absolute;
            top: 60px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .counter-bar {
            height: 15px;
            margin: 5px 0;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        .counter-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        .counter-fill.claro {
            background-color: #87CEEB;
        }
        .counter-fill.saturado {
            background-color: #32CD32;
        }
        .counter-fill.oscuro {
            background-color: #8B0000;
        }
        .counter-value {
            font-size: 12px;
            margin-left: 5px;
            color: #ccc;
        }
        .mother-node {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.3) 70%, rgba(255,255,255,0) 100%);
            cursor: pointer;
            z-index: 200;
            display: none;
            animation: pulse 2s infinite;
            box-shadow: 0 0 20px 10px rgba(255,255,255,0.5);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px 10px rgba(255,255,255,0.5);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 30px 15px rgba(255,255,255,0.7);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px 10px rgba(255,255,255,0.5);
            }
        }
        .media-panel {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            z-index: 300;
            max-width: 300px;
            max-height: 300px;
            display: none;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .media-panel img, .media-panel video {
            max-width: 100%;
            max-height: 280px;
            border-radius: 4px;
        }

        .media-panel .media-caption {
            color: white;
            font-size: 14px;
            margin-top: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">Volver al Inicio</a>
    
    <div class="info-panel">
        <h2>Todos los Nodos</h2>
        <p>Visualización de nodos temáticos sensoriales. Haz clic en los nodos para navegar hacia las diferentes experiencias sensoriales. Los nodos grises te llevan al centro.</p>
    </div>

    <div id="node-info">Mueve el cursor sobre un nodo para ver información</div>
    <!--
    <div id="path-counters">
        <h3>Progreso de Caminos</h3>
        <div>
            <span>Claro:</span>
            <div class="counter-bar">
                <div class="counter-fill claro" id="claro-counter"></div>
            </div>
            <span class="counter-value" id="claro-value">0.0</span>
        </div>
        <div>
            <span>Saturado:</span>
            <div class="counter-bar">
                <div class="counter-fill saturado" id="saturado-counter"></div>
            </div>
            <span class="counter-value" id="saturado-value">0.0</span>
        </div>
        <div>
            <span>Oscuro:</span>
            <div class="counter-bar">
                <div class="counter-fill oscuro" id="oscuro-counter"></div>
            </div>
            <span class="counter-value" id="oscuro-value">0.0</span>
        </div>
    </div>
    -->


    <div id="media-panel" class="media-panel">
        <div id="media-content"></div>
        <div id="media-caption" class="media-caption"></div>
    </div>
    
    
    <!-- Nodos nodriza para cada área temática -->
    <div class="mother-node" id="mother-node-aranias" onclick="openExperience('aranias')"></div>
    <div class="mother-node" id="mother-node-feliz" onclick="openExperience('feliz')"></div>
    <div class="mother-node" id="mother-node-triste" onclick="openExperience('triste')"></div>

    <script>
        // Configuración general
        const INITIAL_NODES_PER_PATH = 30; // Número inicial de nodos por camino
        const TOTAL_NODES = 1500; // Aumentado para tener más nodos neutros
        const NEUTRAL_NODES = TOTAL_NODES - (INITIAL_NODES_PER_PATH * 9);
        
        // Variables para la cámara/vista
        let viewX = 0;
        let viewY = 0;
        let targetViewX = 0;
        let targetViewY = 0;
        let initialViewX = 0;
        let initialViewY = 0;
        
        // Variables para interacción
        let hoveredNode = null;
        let lastHoveredNode = null;
        let selectedNode = null;
        let selectedPath = null;
        let hoverScale = 1.0;
        let hoverTargetScale = 1.0;
        
        // Arreglos para almacenar nodos y enlaces
        const nodes = [];
        const links = [];
        let currentNodesPerPath = INITIAL_NODES_PER_PATH; // Número actual de nodos por camino
        
        // Variable para el elemento de información del nodo
        let nodeInfo;
        let pathCounters;
        let motherNodes = {};
        
        // Variables para efectos visuales
        let noiseOffset = 0;
        let globalTime = 0;
        
        // Variables para manejo de media
        let mediaPanel;
        let currentAudio = null;
        let audioPlaying = false;
        let lastAudioNodeId = null;
        let audioTimeout = null;
        let hoverDebounceTimeout = null;
        let isAudioLoading = false;
        
        // Áreas temáticas (centros y colores)
        let thematicAreas = [];
        
        // Área temática actualmente seleccionada
        let currentArea = null;
        
        // Contadores de caminos para cada área temática
        let pathCounts = {
            aranias: { 
                count: 0, 
                maxCount: 3.0, // Ajustado para requerir ~6 clicks efectivos en el mismo camino
                claro: 0,
                saturado: 0,
                oscuro: 0
            },
            feliz: { 
                count: 0, 
                maxCount: 3.0, // Ajustado
                claro: 0,
                saturado: 0,
                oscuro: 0
            },
            triste: { 
                count: 0, 
                maxCount: 3.0, // Ajustado
                claro: 0,
                saturado: 0,
                oscuro: 0
            }
        };
        
        // Definición de los nodos principales (centrales)
        const mainNodes = [
            { name: "Arañas", id: "aranias" },
            { name: "Feliz/Motivación", id: "feliz" },
            { name: "Triste", id: "triste" }
        ];
        
        // Definición mejorada de rutas sensoriales con distribución específica de recursos
        const sensoryPaths = {
            aranias: [
                {
                    id: "aranias_claro",
                    name: "Camino Miedo - Arañas",
                    textures: [],
                    pathType: "claro",
                    sounds: [],
                    words: ["peligro", "alerta", "cuidado", "advertencia", "amenaza", "vigilancia", "precaución"],
                    colors: ["#ADD8E6", "#87CEEB", "#B0E0E6", "#E0F6FF", "#F0F8FF"],
                    rhythms: ["default"],
                    images: [
                        { url: "arañas/01-textura-00.jpg"},
                        { url: "arañas/01-textura-01.jpg"},
                        { url: "arañas/01-textura-02.jpg" },
                        { url: "arañas/01-textura-03.jpg"}
                    ],
                    videos: [],
                    gifs: [                    ],
                    audios: [
                        { url: "arañas/01-alerta.mp3"}
                    ]
                },
                {
                    id: "aranias_saturado",
                    name: "Camino Susto - Arañas",
                    textures: [],
                    pathType: "saturado",
                    sounds: [],
                    words: ["trampa", "emboscada", "enredo", "captura", "cazador", "acecho", "estrategia"],
                    colors: ["#0000FF", "#4169E1", "#1E90FF", "#0066CC", "#003399"],
                    rhythms: ["rapido"],
                    images: [],
                    videos: [],
                    gifs: [
                        { url: "arañas/02-textura-01.gif"},
                        { url: "arañas/02-textura-02.gif"},
                        { url: "arañas/02-textura-03.gif"}
                    ],
                    audios: [
                        { url: "arañas/02-piiip.mp3" },
                        { url: "arañas/02-woosh-00.wav"},
                        { url: "arañas/02-woosh-01.wav"}
                    ]
                },
                {
                    id: "aranias_oscuro",
                    name: "Camino Calma - Arañas",
                    textures: [],
                    pathType: "oscuro",
                    sounds: [],
                    words: ["observación", "paciencia", "espera", "estrategia", "sigilo", "plan", "táctica", "inteligencia"],
                    colors: ["#00008B", "#191970", "#000080", "#0F0F23", "#1A1A2E"],
                    rhythms: ["desvanece"],
                    images: [],
                    videos: [],
                    gifs: [
                        { url: "arañas/03-textura-01.gif"},
                        { url: "arañas/03-textura-02.gif"},
                        { url: "arañas/03-textura-03.gif"}
                    ],
                    audios: [
                        { url: "arañas/03-chillpad.wav"}
                    ]
                }
            ],
            feliz: [
                {
                    id: "feliz_claro",
                    name: "Camino Claro - Feliz",
                    textures: [],
                    pathType: "claro",
                    sounds: ["risa_suave", "melodia_alegre", "celebracion_ligera"],
                    words: ["éxito", "victoria", "logro", "triunfo", "celebración", "alegría", "satisfacción"],
                    colors: ["#FFCCCB", "#FFC0CB", "#FFB6C1", "#FFE4E1", "#FFF0F5"],
                    rhythms: ["rapido-largo"],
                    images: [],
                    videos: [
                        { url: "", caption: "Alegría" }
                    ],
                    gifs: [],
                    audios: []
                },
                {
                    id: "feliz_saturado",
                    name: "Camino Saturado - Feliz",
                    textures: [],
                    pathType: "saturado",
                    sounds: ["energia_alta", "vitalidad_intensa", "poder_activo"],
                    words: ["energía", "vitalidad", "fuerza", "poder", "impulso", "pasión", "intensidad"],
                    colors: ["#FF0000", "#DC143C", "#B22222", "#CC0000", "#990000"],
                    rhythms: ["ruido"],
                    images: [],
                    videos: [
                        { url: "", caption: "Energía" }
                    ],
                    gifs: [],
                    audios: [
                        { url: "", caption: "Paciencia" }
                    ]
                },
                {
                    id: "feliz_oscuro",
                    name: "Camino Oscuro - Feliz",
                    textures: [],
                    pathType: "oscuro",
                    sounds: ["calma_profunda", "serenidad_total", "paz_interior"],
                    words: ["calma", "serenidad", "paz", "tranquilidad", "armonía", "equilibrio", "estabilidad"],
                    colors: ["#8B0000", "#800000", "#A52A2A", "#660000", "#4D0000"],
                    rhythms: ["lento-largo"],
                    images: [],
                    videos: [],
                    gifs: [],
                    audios: [
                        { url: "", caption: "Serenidad" }
                    ]
                }
            ],
            triste: [
                {
                    id: "triste_claro",
                    name: "Camino Claro - Triste",
                    textures: [],
                    pathType: "claro",
                    sounds: ["suspiro_suave", "llanto_ligero"],
                    words: ["Desánimo", "Desolación", "Amargura", "Pena", "Pesadumbre", "Quebranto", "Melancolía", "Desconsuelo"],
                    colors: ["#90EE90", "#98FB98", "#8FBC8F", "#AFEEEE", "#E0FFFF"],
                    rhythms: ["lento"],
                    images: [],
                   videos: [{ url: "triste/nodoblack2_.mp4" }],
                    gifs: [   ],
                    audios: [
                        { url: "triste/uhllanto.mp3"},
                        { url:  "triste/SADMUSICpiano.mp3"}, 
                        { url:  "triste/latidodecorazon.mp3"}, 
                        { url:  "triste/dramapista.mp3" }
                    ]
                },
                {
                    id: "triste_saturado",
                    name: "Camino Saturado - Triste",
                    textures: [],
                    pathType: "saturado",
                    sounds: ["llanto_intenso", "dolor_agudo", "angustia_profunda"],
                    words: ["Angustia", "Nostalgia", "Añoranza", "Tristeza", "Aflicción"],
                    colors: ["#00FF00", "#32CD32", "#3CB371", "#00CC00", "#009900"],
                    rhythms: ["ruido-largo"],
                    images: [],
                    videos: [  ],
                    gifs: [
                        { url: "triste/identidad.gif" },
                 {url: "triste/recuerdo.gif"} ],
                    audios: [
                        { url: "triste/sad1.wav" },
                       {url: "triste/sad2.wav"}, 
                       {url: "triste/sad3.wav"}, 
                       {url: "triste/SADMUSIC.mp3"}
                    ]
                },
                {
                    id: "triste_oscuro",
                    name: "Camino Oscuro - Triste",
                    textures: [],
                    pathType: "oscuro",
                    sounds: ["silencio_vacio", "resignacion_total", "final_definitivo"],
                    words: ["Nostalgia", "Recuerdo", "Dolor", "Despedida", "Desequilibrio"],
                    colors: ["#006400", "#2E8B57", "#228B22", "#004400", "#003300"],
                    rhythms: ["desvanece-inversa"],
                    images: [],
                    videos: [   ],
                    gifs: [
                        {url:"triste/enredar.gif"}
                           {url:"triste/interno.gif"}
                    ],
                    audios: [
                         { url: "triste/cuak.mp3" }, 
                         { url: "triste/publicogritando.mp3" } ]
                }
            ]
        };  

        // Configuración de los anillos de distribución
        const RING_CONFIG = {
            CENTER: {
                countPerPath: 1, // 1 nodo por camino = 9 nodos total
                radius: 150
            },
            MIDDLE: {
                countPerPath: 10, // 10 nodos por camino = 90 nodos total
                innerRadius: 200,
                outerRadius: 400
            },
            NUCLEUS: {
                // El resto de nodos (30 - 1 - 10 = 19) por camino = 171 nodos total
                innerRadius: 450,
                outerRadius: 800
            }
        };

        // Cargar contadores desde sessionStorage si existen
        function loadCountersFromStorage() {
            // Resetear todos los contadores a 0
            for (let area in pathCounts) {
                pathCounts[area].count = 0;
                pathCounts[area].claro = 0;
                pathCounts[area].saturado = 0;
                pathCounts[area].oscuro = 0;
            }
            
            // Limpiar el sessionStorage
            sessionStorage.removeItem('pathCounts');
            
            updateCounterDisplay();
        }
        
        // Guardar contadores en sessionStorage
        function saveCountersToStorage() {
            sessionStorage.setItem('pathCounts', JSON.stringify(pathCounts));
        }
        
        // Actualizar visualización de contadores
        function updateCounterDisplay() {
            if (currentArea) {
                const areaCount = pathCounts[currentArea].count;
                const maxCount = pathCounts[currentArea].maxCount;
                
                const claroCount = pathCounts[currentArea].claro;
                const saturadoCount = pathCounts[currentArea].saturado;
                const oscuroCount = pathCounts[currentArea].oscuro;
                
                // Actualizar barras de progreso (ahora basadas en maxCount)
                const claroPercentage = Math.min(100, (claroCount / maxCount) * 100);
                const saturadoPercentage = Math.min(100, (saturadoCount / maxCount) * 100);
                const oscuroPercentage = Math.min(100, (oscuroCount / maxCount) * 100);
                /*
                document.getElementById('claro-counter').style.width = claroPercentage + '%';
                document.getElementById('saturado-counter').style.width = saturadoPercentage + '%';
                document.getElementById('oscuro-counter').style.width = oscuroPercentage + '%';
                
                // Actualizar valores numéricos
                document.getElementById('claro-value').textContent = claroCount.toFixed(1);
                document.getElementById('saturado-value').textContent = saturadoCount.toFixed(1);
                document.getElementById('oscuro-value').textContent = oscuroCount.toFixed(1);
                */
                if (areaCount >= maxCount) {
                    console.log("Mostrando nodo nodriza para: " + currentArea);
                    showMotherNode(currentArea);
                } else {
                    hideAllMotherNodes();
                }
            } else {
                /*
                document.getElementById('claro-counter').style.width = '0%';
                document.getElementById('saturado-counter').style.width = '0%';
                document.getElementById('oscuro-counter').style.width = '0%';
                document.getElementById('claro-value').textContent = '0.0';
                document.getElementById('saturado-value').textContent = '0.0';
                document.getElementById('oscuro-value').textContent = '0.0';
                */
                hideAllMotherNodes();
            }
        }
        
        // Mostrar el nodo nodriza específico para un área
        function showMotherNode(areaId) {
            console.log("Intentando mostrar nodo nodriza para: " + areaId);
            
            hideAllMotherNodes();
            
            const motherNode = document.getElementById(`mother-node-${areaId}`);
            if (motherNode) {
                console.log("Nodo nodriza encontrado, mostrando...");
                
                motherNode.style.display = 'block';
                motherNode.style.opacity = '1';
                
                motherNode.style.left = (windowWidth / 2 - 30) + 'px';
                motherNode.style.top = (windowHeight / 2 - 30) + 'px';
                
                let dominantColor = 'white';
                
                if (areaId === 'aranias') {
                    dominantColor = '#0000FF';
                    motherNode.style.boxShadow = '0 0 30px 15px rgba(0,0,255,0.7)';
                } else if (areaId === 'feliz') {
                    dominantColor = '#FF0000';
                    motherNode.style.boxShadow = '0 0 30px 15px rgba(255,0,0,0.7)';
                } else if (areaId === 'triste') {
                    dominantColor = '#00FF00';
                    motherNode.style.boxShadow = '0 0 30px 15px rgba(0,255,0,0.7)';
                }
                
                motherNode.style.background = `radial-gradient(circle, ${dominantColor} 0%, rgba(255,255,255,0.3) 70%, rgba(255,255,255,0) 100%)`;
                
                motherNode.offsetHeight;
            } else {
                console.error("No se encontró el nodo nodriza para: " + areaId);
            }
        }
        
        // Ocultar todos los nodos nodriza
        function hideAllMotherNodes() {
            document.querySelectorAll('.mother-node').forEach(node => {
                node.style.opacity = '0';
                setTimeout(() => {
                    if (node.style.opacity === '0') {
                        node.style.display = 'none';
                    }
                }, 500);
            });
        }
        
        // Abrir experiencia basada en el área y tipo sensorial dominante
        function openExperience(areaId) {
            let dominantSensoryType = "claro";
            
            if (pathCounts[areaId]) {
                const claroCount = pathCounts[areaId].claro;
                const saturadoCount = pathCounts[areaId].saturado;
                const oscuroCount = pathCounts[areaId].oscuro;
                
                if (saturadoCount > claroCount && saturadoCount > oscuroCount) {
                    dominantSensoryType = "saturado";
                } else if (oscuroCount > claroCount && oscuroCount > saturadoCount) {
                    dominantSensoryType = "oscuro";
                }
            }
            
            // Guardar información en sessionStorage
            sessionStorage.setItem('selectedArea', areaId);
            sessionStorage.setItem('dominantSensoryType', dominantSensoryType);
            
            // Redirigir al redireccionador con los parámetros
            window.location.href = `redireccionador.html?area=${areaId}&type=${dominantSensoryType}`;
        }
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1);
            
            noiseOffset = random(1000);
            
            const worldWidth = width * 4;
            const worldHeight = height * 4;
            
            initialViewX = worldWidth * 0.5;
            initialViewY = worldHeight * 0.5;
            
            const areaCenterRadius = min(worldWidth, worldHeight) * 0.5;

            thematicAreas = [
                { // Área 1: Arañas (Azul) - Arriba
                    name: "Arañas",
                    id: "aranias",
                    center: { x: initialViewX + cos(PI/2) * areaCenterRadius, y: initialViewY + sin(PI/2) * areaCenterRadius },
                    color: color(0, 0, 255)
                },
                { // Área 2: Feliz/Motivación (Rojo) - Abajo Izquierda
                    name: "Feliz/Motivación",
                    id: "feliz",
                    center: { x: initialViewX + cos(PI * 7/6) * areaCenterRadius, y: initialViewY + sin(PI * 7/6) * areaCenterRadius },
                    color: color(255, 0, 0)
                },
                { // Área 3: Triste (Verde) - Abajo Derecha
                    name: "Triste",
                    id: "triste",
                    center: { x: initialViewX + cos(PI * 11/6) * areaCenterRadius, y: initialViewY + sin(PI * 11/6) * areaCenterRadius },
                    color: color(0, 255, 0)
                }
            ];
            
            targetViewX = initialViewX;
            targetViewY = initialViewY;

            createNodes();
            createLinks();
            
            nodeInfo = select('#node-info');
            
            motherNodes = {
                aranias: document.getElementById('mother-node-aranias'),
                feliz: document.getElementById('mother-node-feliz'),
                triste: document.getElementById('mother-node-triste')
            };

            mediaPanel = document.getElementById('media-panel');
            
            loadCountersFromStorage();
            
            window.openExperience = openExperience;
        }
        
        // Nueva función para crear nodos (separada de setup)
        function createNodes() {
            // Configuración de distribución ponderada (ajusta estos valores para cambiar la densidad)
            const nucleusConcentration = 2.0; // Mayor valor = más concentrados cerca del núcleo
            const maxDistanceFactor = 1.5; // Qué tan lejos se pueden extender los nodos desde el centro temático (ajustado un poco)

            // Configuración del ruido/jitter (ajusta estos valores)
            const jitterAmount = 30; // Cantidad máxima de desplazamiento aleatorio

            // Crear nodos para cada ruta sensorial
            for (let areaIndex = 0; areaIndex < thematicAreas.length; areaIndex++) {
                const area = thematicAreas[areaIndex];
                const mainNodeId = area.id;
                const paths = sensoryPaths[mainNodeId];

                for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {
                    const path = paths[pathIndex];

                    let pathType = "claro";
                    if (path.id.includes("saturado")) {
                        pathType = "saturado";
                    } else if (path.id.includes("oscuro")) {
                        pathType = "oscuro";
                    }

                    // Crear nodos para este camino con distribución ponderada
                    for (let i = 0; i < INITIAL_NODES_PER_PATH; i++) {
                        // Generar una distancia ponderada: sesgada hacia distancias más pequeñas (cerca del núcleo temático)
                        const distanceFactor = pow(random(), nucleusConcentration); // 0 a 1, sesgado hacia 0 (cerca del centro del área)
                        // La distancia real del nodo desde el centro del área temática
                        const maxAreaDistance = distance2D(area.center.x, area.center.y, initialViewX, initialViewY) * maxDistanceFactor;
                        const distance = distanceFactor * maxAreaDistance; // Distancia desde el centro del área temática

                        // Calcular el ángulo de dispersión
                        let angle;

                        if (distanceFactor < 0.3) { // Si está muy cerca del centro del área (núcleo)
                           angle = random(TWO_PI); // Dispersión completa (360 grados) alrededor del centro del área
                        } else { // Si está más lejos del centro del área
                           // Calcular el ángulo base desde el centro del área temática HACIA el centro general
                           const angleToCenter = atan2(initialViewY - area.center.y, initialViewX - area.center.x);
                           // Añadir variación al ángulo. La variación aumenta con la distancia DESDE el núcleo temático
                           // y está centrada en el ángulo hacia el centro general.
                           const angleVariation = map(distanceFactor, 0.3, 1, PI / 8, PI / 1.5); // Poca variación cerca del núcleo, mucha lejos (ajustar rango)
                           angle = angleToCenter + random(-angleVariation, angleVariation);
                        }


                        // Calcular la posición del nodo moviéndose desde el centro del área temática
                        let x = area.center.x + cos(angle) * distance;
                        let y = area.center.y + sin(angle) * distance;

                        // Añadir ruido/jitter a la posición final para romper la linealidad
                        x += random(-jitterAmount, jitterAmount);
                        y += random(-jitterAmount, jitterAmount);

                         createSensoryNode(x, y, area, path, pathType, i, distanceFactor < 0.5); // Marcar como 'centerNode' si está relativamente cerca del centro general
                    }
                }
            }

            // Crear nodos neutros (expandimos su área de distribución)
            // Distribuirlos en un área más grande que cubra los núcleos temáticos.
            const neutralAreaWidth = width * 6; // Ajusta según sea necesario para cubrir los núcleos
            const neutralAreaHeight = height * 6; // Ajusta según sea necesario

            for (let i = 0; i < NEUTRAL_NODES; i++) {
                // Generar posiciones aleatorias dentro del área expandida centrada en initialViewX/Y
                const x = random(initialViewX - neutralAreaWidth / 2, initialViewX + neutralAreaWidth / 2);
                const y = random(initialViewY - neutralAreaHeight / 2, initialViewY + neutralAreaHeight / 2);

                const grayValue = random(100, 180);
                const nodeColor = color(grayValue, grayValue, grayValue, 180);

                nodes.push({
                    x: x,
                    y: y,
                    baseX: x,
                    baseY: y,
                    vx: 0,
                    vy: 0,
                    radius: random(5, 12),
                    color: nodeColor,
                    nodeType: "neutral",
                    pathId: "neutral",
                    pathType: "neutral",
                    mainNodeId: "neutral",
                    thematicArea: -1,
                    name: `Nodo Neutral ${i+1}`,
                    noiseOffsetX: random(1000),
                    noiseOffsetY: random(1000),
                    noiseScale: random(0.01, 0.02),
                    screenX: 0,
                    screenY: 0,
                    visible: true,
                    active: true,
                    activeTransition: 1.0,
                    targetActiveTransition: 1.0,
                    labelOpacity: 0,
                    scale: 1.0,
                    targetScale: 1.0,
                    pulseOffset: random(TWO_PI),
                    texture: null,
                    sound: null,
                    word: "neutral",
                    rhythm: "neutral",
                    pathColor: `rgb(${grayValue},${grayValue},${grayValue})`,
                    transitionOffsetX: random(-5, 5),
                    transitionOffsetY: random(-5, 5),
                    nodeUniqueId: 10000 + i,
                    mediaType: null,
                    mediaUrl: null,
                    mediaCaption: null
                });
            }
        }
        
        // Nueva función auxiliar para crear nodos sensoriales
        function createSensoryNode(x, y, area, path, pathType, index, isCenterNode) {
            const distanceFactor = isCenterNode ? 0.3 : pow(random(), 1.5);
            const sectionIndex = floor(index / (currentNodesPerPath / 3));
            
            const texture = path.textures[min(sectionIndex, path.textures.length - 1)];
            const nodeSound = path.sounds[min(sectionIndex, path.sounds.length - 1)];
            const word = path.words[floor(random(path.words.length))];
            const nodeColor = path.colors[min(sectionIndex, path.colors.length - 1)];
            
            // Obtener el ritmo del array de ritmos
            const rhythm = path.rhythms && path.rhythms.length > 0 ? path.rhythms[0] : "constante";
            const validatedRhythm = validateRhythm(rhythm);
            
            const nodeUniqueId = (thematicAreas.indexOf(area) * 1000) + (sensoryPaths[area.id].indexOf(path) * 100) + index;
            const hasMedia = ((nodeUniqueId * 13) % 10) < 6;
            
            let mediaType = null;
            let mediaUrl = null;
            let mediaCaption = null;
            
            if (hasMedia) {
                // Crear array con los tipos de media disponibles
                const availableMediaTypes = [];
                if (path.images.length > 0) availableMediaTypes.push(0);
                if (path.videos.length > 0) availableMediaTypes.push(1);
                if (path.gifs.length > 0) availableMediaTypes.push(2);
                if (path.audios.length > 0) availableMediaTypes.push(3);

                // Si hay tipos de media disponibles
                if (availableMediaTypes.length > 0) {
                    // Seleccionar un tipo aleatorio de los disponibles
                    const randomIndex = floor(random(availableMediaTypes.length));
                    const mediaTypeSelector = availableMediaTypes[randomIndex];

                    if (mediaTypeSelector === 0) {
                        mediaType = "image";
                        const mediaIndex = floor(random(path.images.length));
                        mediaUrl = path.images[mediaIndex].url;
                        mediaCaption = path.images[mediaIndex].caption;
                    } else if (mediaTypeSelector === 1) {
                        mediaType = "video";
                        const mediaIndex = floor(random(path.videos.length));
                        mediaUrl = path.videos[mediaIndex].url;
                        mediaCaption = path.videos[mediaIndex].caption;
                    } else if (mediaTypeSelector === 2) {
                        mediaType = "gif";
                        const mediaIndex = floor(random(path.gifs.length));
                        mediaUrl = path.gifs[mediaIndex].url;
                        mediaCaption = path.gifs[mediaIndex].caption;
                    } else if (mediaTypeSelector === 3) {
                        mediaType = "audio";
                        const mediaIndex = floor(random(path.audios.length));
                        mediaUrl = path.audios[mediaIndex].url;
                        mediaCaption = path.audios[mediaIndex].caption;
                    }
                }
            }
            
            nodes.push({
                x: x,
                y: y,
                baseX: x,
                baseY: y,
                vx: 0,
                vy: 0,
                radius: random(12, 18),
                color: color(
                    red(color(nodeColor)) * distanceFactor,
                    green(color(nodeColor)) * distanceFactor,
                    blue(color(nodeColor)) * distanceFactor,
                    200
                ),
                nodeType: "sensory",
                pathId: path.id,
                pathType: pathType,
                mainNodeId: area.id,
                thematicArea: thematicAreas.indexOf(area),
                name: `${path.name} - Nodo ${index+1}`,
                noiseOffsetX: random(1000),
                noiseOffsetY: random(1000),
                noiseScale: random(0.01, 0.03),
                screenX: 0,
                screenY: 0,
                visible: true,
                active: true,
                activeTransition: 1.0,
                targetActiveTransition: 1.0,
                labelOpacity: 0,
                scale: 1.0,
                targetScale: 1.0,
                pulseOffset: random(TWO_PI),
                texture: texture,
                sound: nodeSound,
                word: word,
                rhythm: validatedRhythm,
                pathColor: nodeColor,
                distanceFactor: distanceFactor,
                transitionOffsetX: random(-5, 5),
                transitionOffsetY: random(-5, 5),
                nodeUniqueId: nodeUniqueId,
                mediaType: mediaType,
                mediaUrl: mediaUrl,
                mediaCaption: mediaCaption
            });
        }
        
        function createLinks() {
            // Crear enlaces entre nodos de la misma ruta sensorial
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "sensory") {
                    const pathId = nodes[i].pathId;

                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "sensory") {
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );

                            const maxDist = min(width, height) * 0.8; // Reducido de 1.0 a 0.8

                            // Calcular distancia promedio de AMBOS nodos al centro GENERAL
                            const distFromOverallCenter1 = distance2D(nodes[i].x, nodes[i].y, initialViewX, initialViewY);
                            const distFromOverallCenter2 = distance2D(nodes[j].x, nodes[j].y, initialViewX, initialViewY);
                            const avgDistFromOverallCenter = (distFromOverallCenter1 + distFromOverallCenter2) / 2;

                            // Ajustar probabilidad de conexión: mayor cerca del centro general (zona de mezcla),
                            // mayor dentro del mismo camino lejos del centro general (zona de núcleos)
                            let connectionChance;

                            if (avgDistFromOverallCenter < min(width, height) * 0.4) { // Zona cercana al centro general
                                connectionChance = nodes[i].pathId === nodes[j].pathId ? 0.3 : 0.5; // Reducido de 0.5/0.8 a 0.3/0.5
                            } else if (avgDistFromOverallCenter < min(width, height) * 0.7) { // Zona intermedia
                                connectionChance = nodes[i].pathId === nodes[j].pathId ? 0.4 : 0.3; // Reducido de 0.6/0.5 a 0.4/0.3
                            } else { // Zona lejana al centro general (núcleos periféricos)
                                connectionChance = nodes[i].pathId === nodes[j].pathId ? 0.6 : 0.1; // Reducido de 0.9/0.2 a 0.6/0.1
                            }

                            // Reducir ligeramente la probabilidad de conexión a medida que la distancia entre los nodos aumenta
                            const distanceReduction = map(dist, 0, maxDist, 1.0, 0.3); // Aumentado el factor de reducción
                            connectionChance *= distanceReduction;

                            if (dist < maxDist && random() < connectionChance) {
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: nodes[i].pathId === nodes[j].pathId ? pathId : "cross_area",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 3)) // Reducido de 1-4 a 1-3
                                    ),
                                    velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                        x: random(-0.1, 0.1),
                                        y: random(-0.1, 0.1)
                                    })),
                                    color: nodes[i].pathId === nodes[j].pathId ?
                                        nodes[i].color :
                                        lerpColor(nodes[i].color, nodes[j].color, 0.5),
                                    opacity: random(0.4, 0.7), // Reducido de 0.5-0.8 a 0.4-0.7
                                    pulseRate: random(0.001, 0.005),
                                    pulseAmount: random(0.1, 0.3)
                                });
                            }
                        }
                    }
                }
            }

            // Crear algunos enlaces entre nodos neutros (mantenemos la lógica actual)
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "neutral") {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "neutral") {
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );

                            const maxDist = min(width, height) * 0.5;
                            if (dist < maxDist && random() < 0.08) {
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: "neutral",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 2))
                                    ),
                                    velocities: Array(floor(random(1, 2))).fill().map(() => ({
                                        x: random(-0.05, 0.05),
                                        y: random(-0.05, 0.05)
                                    })),
                                    color: color(150, 150, 150, 100),
                                    opacity: random(0.2, 0.4),
                                    pulseRate: random(0.001, 0.002),
                                    pulseAmount: random(0.05, 0.1)
                                });
                            }
                        }
                    }
                }
            }

             // Crear algunos enlaces entre nodos temáticos y neutros (mantenemos la lógica actual)
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "sensory") {
                    for (let j = 0; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "neutral") {
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );

                            const maxDist = min(width, height) * 0.6;
                            if (dist < maxDist && random() < 0.03) {
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: "transition",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 3))
                                    ),
                                    velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                        x: random(-0.08, 0.08),
                                        y: random(-0.08, 0.08)
                                    })),
                                    color: lerpColor(
                                        nodes[i].color,
                                        color(150, 150, 150),
                                        0.5
                                    ),
                                    opacity: random(0.3, 0.6),
                                    pulseRate: random(0.001, 0.004),
                                    pulseAmount: random(0.1, 0.25)
                                });
                            }
                        }
                    }
                }
            }

             // Crear algunos enlaces adicionales entre áreas temáticas diferentes (ajustamos probabilidades)
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "sensory") {
                    for (let j = 0; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "sensory" && nodes[j].thematicArea !== nodes[i].thematicArea) {
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );

                            const maxDist = min(width, height) * 0.7;

                            // Calcular distancia promedio de AMBOS nodos al centro GENERAL
                            const distFromOverallCenter1 = distance2D(nodes[i].x, nodes[i].y, initialViewX, initialViewY);
                            const distFromOverallCenter2 = distance2D(nodes[j].x, nodes[j].y, initialViewX, initialViewY);
                            const avgDistFromOverallCenter = (distFromOverallCenter1 + distFromOverallCenter2) / 2;

                            // Probabilidad de conexión entre áreas: mucho mayor cerca del centro general
                            let connectionChance;
                             if (avgDistFromOverallCenter < min(width, height) * 0.4) { // Zona cercana al centro general
                                connectionChance = 0.15; // Alta probabilidad de conexión entre áreas diferentes
                            } else if (avgDistFromOverallCenter < min(width, height) * 0.7) { // Zona intermedia
                                connectionChance = 0.05; // Menor probabilidad
                            } else { // Zona lejana (núcleos periféricos)
                                connectionChance = 0.005; // Muy baja probabilidad
                            }


                            // Reducir ligeramente la probabilidad de conexión a medida que la distancia entre los nodos aumenta
                            const distanceReduction = map(dist, 0, maxDist, 1.0, 0.5); // Menos probable cuanto más lejos
                             connectionChance *= distanceReduction;


                            if (dist < maxDist && random() < connectionChance) {
                                const mixedColor = lerpColor(
                                    nodes[i].color,
                                    nodes[j].color,
                                    0.5
                                );

                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: "cross_area",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(2, 4))
                                    ),
                                    velocities: Array(floor(random(2, 4))).fill().map(() => ({
                                        x: random(-0.1, 0.1),
                                        y: random(-0.1, 0.1)
                                    })),
                                    color: mixedColor,
                                    opacity: random(0.4, 0.7),
                                    pulseRate: random(0.002, 0.005),
                                    pulseAmount: random(0.15, 0.3)
                                });
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            background(0);
            
            globalTime += 0.01;
            
            viewX = lerp(viewX, targetViewX, 0.05);
            viewY = lerp(viewY, targetViewY, 0.05);
            
            translate(width/2 - viewX, height/2 - viewY);
            
            updateScreenPositions();
            
            checkMouseOverNodes();
            
            drawLinks();
            
            drawNodes();
            
            updateNodePositions();
            
            if (selectedPath) {
                emphasizeSelectedPath();
            }
            
            resetMatrix();
            updateNodeInfo();
        }
        
        function updateNodeVisibility(selectedPathType) {
            if (!currentArea) return;
            
            let activeNodesCount = 0;
            let nodesToRemove = [];
            
            // Primera pasada: contar nodos activos y marcar nodos para eliminar
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.nodeType === "sensory" && node.mainNodeId === currentArea && 
                    node.pathType === selectedPathType && node.activeTransition > 0.5) {
                    activeNodesCount++;
                }
                
                if (node.nodeType === "sensory" && node.mainNodeId === currentArea && 
                    node.pathType !== selectedPathType && node.activeTransition <= 0.1) {
                    nodesToRemove.push(i);
                }
            }
            
            // Segunda pasada: actualizar visibilidad de nodos restantes
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                if (node.nodeType === "sensory") {
                    if (node.mainNodeId === currentArea) {
                        if (node.pathType === selectedPathType) {
                            node.targetActiveTransition = 1.0;
                            node.targetScale = 1.0;
                            
                            if (activeNodesCount < currentNodesPerPath && random() < 0.05) {
                                generateNewNode(currentArea, selectedPathType, node);
                                activeNodesCount++;
                            }
                        } else {
                            if (random() < 0.2) {
                                node.targetActiveTransition = 0.0;
                            } else {
                                node.targetActiveTransition = Math.max(0, node.activeTransition - 0.1);
                            }
                        }
                    } else {
                        node.targetActiveTransition = 0.3;
                        node.targetScale = 1.0;
                    }
                } else if (node.nodeType === "neutral") {
                    node.targetActiveTransition = 0.7;
                    node.targetScale = 1.0;
                }
            }
            
            // Eliminar nodos marcados (en orden inverso para no afectar los índices)
            for (let i = nodesToRemove.length - 1; i >= 0; i--) {
                const nodeIndex = nodesToRemove[i];
                nodes.splice(nodeIndex, 1);
                
                // Actualizar índices en los enlaces
                for (let link of links) {
                    if (link.source > nodeIndex) link.source--;
                    if (link.target > nodeIndex) link.target--;
                }
            }
        }
        
        function emphasizeSelectedPath() {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.nodeType === "sensory") {
                    if (node.pathId === selectedPath) {
                        node.targetScale = 1.0;
                        node.color = color(
                            red(color(node.pathColor)),
                            green(color(node.pathColor)),
                            blue(color(node.pathColor)),
                            230
                        );
                    } else {
                        node.targetScale = 1.0;
                        node.color = color(
                            red(color(node.pathColor)) * 0.7,
                            green(color(node.pathColor)) * 0.7,
                            blue(color(node.pathColor)) * 0.7,
                            100
                        );
                    }
                } else if (node.nodeType === "neutral") {
                    node.targetScale = 1.0;
                    node.color = color(100, 100, 100, 80);
                }
            }
            
            for (let link of links) {
                if (link.pathId === selectedPath) {
                    link.opacity = random(0.7, 0.9);
                    link.pulseAmount = random(0.2, 0.4);
                } else if (link.pathId !== "neutral") {
                    link.opacity = random(0.1, 0.3);
                    link.pulseAmount = random(0.05, 0.1);
                } else {
                    link.opacity = random(0.05, 0.15);
                }
            }
        }
        
        function drawLinks() {
            for (const link of links) {
                const source = nodes[link.source];
                const target = nodes[link.target];
                
                // Verificar que ambos nodos existan
                if (!source || !target) {
                    continue;
                }
                
                if (source.visible && target.visible && 
                    source.activeTransition > 0.1 && target.activeTransition > 0.1) {
                    
                    const pulseEffect = sin(globalTime * link.pulseRate * TWO_PI) * link.pulseAmount + 1;
                    const transitionFactor = min(source.activeTransition, target.activeTransition);
                    const currentOpacity = link.opacity * pulseEffect * transitionFactor;
                    
                    stroke(
                        red(link.color), 
                        green(link.color), 
                        blue(link.color), 
                        alpha(link.color) * currentOpacity
                    );
                    strokeWeight(1);
                    
                    drawOrganicLine2D(
                        source.x, source.y,
                        target.x, target.y,
                        link.points
                    );
                    
                    updateLinkPoints(link);
                }
            }
        }
        
        function drawNodes() {
            noStroke();
            
            for (let i = 0; i < nodes.length; i++) {
                if (i !== hoveredNode && i !== selectedNode) {
                    drawNode(i);
                }
            }
            
            if (selectedNode !== null && nodes[selectedNode]) {
                drawNode(selectedNode);
            }
            
            if (hoveredNode !== null && hoveredNode !== selectedNode && nodes[hoveredNode]) {
                drawNode(hoveredNode);
            }
        }
        
        function drawNode(i) {
            const node = nodes[i];
            if (!node) return;
            
            node.activeTransition = lerp(node.activeTransition, node.targetActiveTransition, 0.05);
            
            if (node.visible && node.activeTransition > 0.01) {
                node.scale = lerp(node.scale, node.targetScale, 0.2);
                
                const pulseEffect = getRhythmEffect(node.rhythm, node.pulseOffset);
                const currentScale = node.scale * pulseEffect * node.activeTransition;
                
                const transitionX = node.x + node.transitionOffsetX * (1 - node.activeTransition);
                const transitionY = node.y + node.transitionOffsetY * (1 - node.activeTransition);
                
                // Nodo sin textura - usar el método original
                drawRegularNode(node, transitionX, transitionY, currentScale, i);
                
                // Mostrar palabra si está seleccionado o en hover
                if (node.word && (selectedNode === i || hoveredNode === i)) {
                    fill(255, 255, 255, 230 * node.activeTransition);
                    textAlign(CENTER, CENTER);
                    textSize(12);
                    text(node.word, transitionX, transitionY - node.radius * currentScale - 10);
                }
            }
        }
        
        // Función para dibujar nodos regulares (sin textura)
        function drawRegularNode(node, x, y, currentScale, nodeIndex) {
            // Efectos de bloom (varias capas con diferentes tamaños y opacidades)
            for (let j = 3; j > 0; j--) {
                if (selectedNode === nodeIndex || hoveredNode === nodeIndex) {
                    fill(
                        min(red(node.color) + 70, 255),
                        min(green(node.color) + 70, 255),
                        min(blue(node.color) + 70, 255),
                        60 / j * node.activeTransition
                    );
                } else {
                    fill(
                        red(node.color), 
                        green(node.color), 
                        blue(node.color), 
                        50 / j * node.activeTransition
                    );
                }
                circle(x, y, node.radius * 2 * j * currentScale);
            }
            
            // Nodo principal
            if (selectedNode === nodeIndex || hoveredNode === nodeIndex) {
                fill(
                    min(red(node.color) + 70, 255),
                    min(green(node.color) + 70, 255),
                    min(blue(node.color) + 70, 255),
                    230 * node.activeTransition
                );
            } else {
                fill(
                    red(node.color), 
                    green(node.color), 
                    blue(node.color), 
                    200 * node.activeTransition 
                );
            }
            circle(x, y, node.radius * 2 * currentScale);

        }
        
        
        function getRhythmEffect(rhythm, pulseOffset) {
            // Asegurarnos de que rhythm sea un string válido
            if (!rhythm || typeof rhythm !== 'string') {
                return 1.0;
            }

            // Normalizar el nombre del ritmo
            const normalizedRhythm = rhythm.toLowerCase().trim();

            switch(normalizedRhythm) {
                case "rapido":
                    // Oscilación medianamente rápida
                    return sin(globalTime * 1.5 + pulseOffset) * 0.2 + 1;
                    
                case "lento":
                    // Oscilación medianamente lenta
                    return sin(globalTime * 0.7 + pulseOffset) * 0.2 + 1;
                    
                case "lento-largo":
                    // Oscilación lenta y larga entre lo más chico y lo más grande
                    return sin(globalTime * 0.3 + pulseOffset) * 0.4 + 0.8;
                    
                case "rapido-corto":
                    // Oscilación rápida y corta entre lo más chico y lo más grande
                    return sin(globalTime * 2.5 + pulseOffset) * 0.15 + 0.9;
                    
                case "rapido-largo":
                    // Oscilación rápida y larga
                    return sin(globalTime * 2 + pulseOffset) * 0.4 + 0.8;
                    
                case "lento-corto":
                    // Oscilación lenta y corta
                    return sin(globalTime * 0.4 + pulseOffset) * 0.15 + 0.9;
                    
                case "ruido":
                    // Oscilación azarosa corta
                    return noise(globalTime * 2 + pulseOffset) * 0.2 + 0.9;
                    
                case "ruido-largo":
                    // Oscilación azarosa larga
                    return noise(globalTime * 0.5 + pulseOffset) * 0.4 + 0.8;
                    
                case "desvanece":
                    // Crece rápido, se achica lento
                    return abs(sin(globalTime * 1.5 + pulseOffset)) * 0.3 + 0.7;
                    
                case "desvanece-inversa":
                    // Crece lento, se achica rápido
                    return 1 - (abs(sin(globalTime * 1.5 + pulseOffset)) * 0.3 + 0.7);
                    
                case "neutral":
                    // Sin efecto para nodos neutros
                    return 1.0;
                    
                case "default":
                    // Oscilación constante, normal
                    return sin(globalTime * 0.5 + pulseOffset) * 0.1 + 1;
                    
                default:
                    // Ritmo por defecto si no se reconoce
                    console.warn(`Ritmo no reconocido: ${rhythm}, usando ritmo por defecto`);
                    return sin(globalTime * 0.5 + pulseOffset) * 0.1 + 1;
            }
        }
        
        // Función auxiliar para asegurar que los ritmos se asignen correctamente
        function validateRhythm(rhythm) {
            const validRhythms = [
                "rapido",
                "lento",
                "lento-largo",
                "rapido-corto",
                "rapido-largo",
                "lento-corto",
                "ruido",
                "ruido-largo",
                "desvanece",
                "desvanece-inversa",
                "neutral",
                "default"
            ];
            
            if (!rhythm || !validRhythms.includes(rhythm)) {
                console.warn(`Ritmo inválido: ${rhythm}, usando ritmo por defecto`);
                return "default";
            }
            
            return rhythm;
        }
        
        
        function updateNodePositions() {
            for (let node of nodes) {
                const time = frameCount * 0.01;
                const noiseX = noise(node.noiseOffsetX + time) * 2 - 1;
                const noiseY = noise(node.noiseOffsetY + time) * 2 - 1;
                
                node.vx = lerp(node.vx, noiseX * node.noiseScale * 2, 0.02);
                node.vy = lerp(node.vy, noiseY * node.noiseScale * 2, 0.02);
                
                if (node.activeTransition > 0.9) {
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    node.x += (node.baseX - node.x) * 0.01;
                    node.y += (node.baseY - node.y) * 0.01;
                }
                
                if (hoveredNode === nodes.indexOf(node)) {
                    node.targetScale = 1.1;
                } else if (selectedNode !== nodes.indexOf(node) && !selectedPath) {
                    node.targetScale = 1.0;
                }
            }
        }
        
        function updateLinkPoints(link) {
            if (!link.points || !link.velocities || link.points.length !== link.velocities.length) {
                return;
            }
            
            const source = nodes[link.source];
            const target = nodes[link.target];
            
            // Verificar que ambos nodos existan
            if (!source || !target) {
                return;
            }
            
            for (let i = 0; i < link.points.length; i++) {
                const point = link.points[i];
                const velocity = link.velocities[i];
                
                point.x += velocity.x;
                point.y += velocity.y;
                
                const t = (i + 1) / (link.points.length + 1);
                const sourceX = source.x;
                const sourceY = source.y;
                const targetX = target.x;
                const targetY = target.y;
                
                const baseX = sourceX + (targetX - sourceX) * t;
                const baseY = sourceY + (targetY - sourceY) * t;
                
                point.x += (baseX - point.x) * 0.02;
                point.y += (baseY - point.y) * 0.02;
            }
        }
        
        function updateScreenPositions() {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                node.screenX = node.x - viewX + width/2;
                node.screenY = node.y - viewY + height/2;
                
                const margin = node.radius * 3;
                node.visible = 
                    node.screenX + margin >= 0 && 
                    node.screenX - margin <= width && 
                    node.screenY + margin >= 0 && 
                    node.screenY - margin <= height;
            }
        }
        
        function checkMouseOverNodes() {
            lastHoveredNode = hoveredNode;
            hoveredNode = null;
            
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (!node) continue; // Verificar que el nodo existe
                
                if (node.visible && node.activeTransition > 0.5) {
                    const distance = dist(mouseX, mouseY, node.screenX, node.screenY);
                    
                    if (distance < node.radius * node.scale) {
                        hoveredNode = i;
                        break;
                    }
                }
            }
            
            if (hoveredNode !== lastHoveredNode) {
                if (hoveredNode === null) {
                    hideMediaPanel();
                    clearTimeout(audioTimeout);
                    audioTimeout = setTimeout(() => {
                        stopAudio();
                    }, 100);
                } 
                else if (nodes[hoveredNode] && nodes[hoveredNode].nodeType === "sensory" && nodes[hoveredNode].mediaType) {
                    clearTimeout(hoverDebounceTimeout);
                    
                    hoverDebounceTimeout = setTimeout(() => {
                        if (nodes[hoveredNode]) { // Verificar que el nodo aún existe
                            showNodeMedia(nodes[hoveredNode]);
                        }
                    }, 50);
                } else {
                    hideMediaPanel();
                    stopAudio();
                }
            }
        }
        
        function showNodeMedia(node) {
            if (!node || !node.mediaType || !node.mediaUrl) return;
            
            let mediaHTML = '';
            let hasMedia = false;
            
            if (node.mediaType === "image") {
                mediaHTML = `<img src="${node.mediaUrl}" alt="${node.mediaCaption || 'Imagen sensorial'}">`;
                hasMedia = true;
            } else if (node.mediaType === "video") {
                mediaHTML = `<video autoplay loop muted><source src="${node.mediaUrl}" type="video/mp4"></video>`;
                hasMedia = true;
            } else if (node.mediaType === "gif") {
                mediaHTML = `<img src="${node.mediaUrl}" alt="${node.mediaCaption || 'GIF sensorial'}">`;
                hasMedia = true;
            } else if (node.mediaType === "audio") {
                playAudioSafely(node);
                mediaHTML = `<div style="text-align: center; padding: 20px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">🔊</div>
                    <div>Reproduciendo audio</div>
                </div>`;
                hasMedia = true;
            }
            
            if (hasMedia) {
                const mediaContent = document.getElementById('media-content');
                const mediaCaption = document.getElementById('media-caption');
                
                if (mediaContent && mediaCaption) {
                    mediaContent.innerHTML = mediaHTML;
                    mediaCaption.textContent = node.mediaCaption || '';
                    
                    const panel = document.getElementById('media-panel');
                    if (panel) {
                        panel.style.left = (node.screenX - 150) + 'px';
                        panel.style.top = (node.screenY - 320) + 'px';
                        panel.style.display = 'block';
                        panel.style.opacity = '1';
                    }
                }
            } else {
                hideMediaPanel();
            }
        }

        function hideMediaPanel() {
            const panel = document.getElementById('media-panel');
            if (panel) {
                panel.style.opacity = '0';
                setTimeout(() => {
                    if (panel.style.opacity === '0') {
                        panel.style.display = 'none';
                    }
                }, 300);
            }
        }

        function playAudioSafely(node) {
            if (!node || !node.mediaUrl) {
                console.log("No hay archivo de audio para reproducir");
                return;
            }

            if (lastAudioNodeId === node.nodeUniqueId && audioPlaying) {
                return;
            }
            
            if (isAudioLoading || audioPlaying) {
                stopAudio();
            }
            
            isAudioLoading = true;
            lastAudioNodeId = node.nodeUniqueId;
            
            setTimeout(() => {
                try {
                    currentAudio = new Audio();
                    
                    currentAudio.oncanplaythrough = function() {
                        if (!currentAudio) return; // Verificar que el audio aún existe
                        
                        isAudioLoading = false;
                        if (lastAudioNodeId === node.nodeUniqueId) {
                            currentAudio.play()
                                .then(() => {
                                    audioPlaying = true;
                                })
                                .catch(error => {
                                    console.log("Error al reproducir audio:", error);
                                    audioPlaying = false;
                                    currentAudio = null;
                                    isAudioLoading = false;
                                });
                        }
                    };
                    
                    currentAudio.onended = function() {
                        audioPlaying = false;
                        currentAudio = null;
                    };
                    
                    currentAudio.onerror = function() {
                        console.log("Error al cargar audio");
                        audioPlaying = false;
                        currentAudio = null;
                        isAudioLoading = false;
                    };
                    
                    currentAudio.volume = 0.5;
                    currentAudio.src = node.mediaUrl;
                    currentAudio.load();
                } catch (error) {
                    console.log("Error al crear audio:", error);
                    audioPlaying = false;
                    currentAudio = null;
                    isAudioLoading = false;
                }
            }, 100);
        }

        function stopAudio() {
            if (currentAudio) {
                try {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                } catch (error) {
                    console.log("Error al detener audio:", error);
                }
            }
            
            audioPlaying = false;
            isAudioLoading = false;
            currentAudio = null;
        }
        
        function updateNodeInfo() {
            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                let infoText = `${node.name}`;
                
                if (node.nodeType === "sensory") {
                    infoText += ` - Haz clic para seguir la ruta ${node.pathId}`;
                    if (node.texture) infoText += ` | Textura: ${node.texture}`;
                    if (node.sound) infoText += ` | Sonido: ${node.sound}`;
                    if (node.word) infoText += ` | Palabra: ${node.word}`;
                    if (node.mediaType) infoText += ` | Media: ${node.mediaType}`;
                } else {
                    infoText += " - Haz clic para volver al centro";
                }
                
                nodeInfo.html(infoText);
            } else {
                nodeInfo.html("Mueve el cursor sobre un nodo para ver información");
            }
        }
        
        function generateIntermediatePoints2D(x1, y1, x2, y2, numPoints) {
            const points = [];
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                const dirX = x2 - x1;
                const dirY = y2 - y1;
                
                const perpX = -dirY;
                const perpY = dirX;
                
                const perpLength = sqrt(perpX * perpX + perpY * perpY);
                let normPerpX = 0;
                let normPerpY = 0;
                
                if (perpLength > 0) {
                    normPerpX = perpX / perpLength;
                    normPerpY = perpY / perpLength;
                }
                
                const deviation = random(-30, 30);
                
                points.push({
                    x: baseX + normPerpX * deviation,
                    y: baseY + normPerpY * deviation
                });
            }
            
            return points;
        }
        
        function drawOrganicLine2D(x1, y1, x2, y2, points) {
            noFill();
            beginShape();
            vertex(x1, y1);
            
            for (const point of points) {
                vertex(point.x, point.y);
            }
            
            vertex(x2, y2);
            endShape();
        }
        
        function distance2D(x1, y1, x2, y2) {
            return sqrt(
                (x2 - x1) * (x2 - x1) + 
                (y2 - y1) * (y2 - y1)
            );
        }
        
        function navigateToThematicArea(areaIndex) {
            const area = thematicAreas[areaIndex];
            
            const dirX = area.center.x - targetViewX;
            const dirY = area.center.y - targetViewY;
            
            const distance = sqrt(dirX * dirX + dirY * dirY);
            
            if (distance > 0) {
                const movePercentage = map(distance, 0, width * 2, 0.3, 0.6);
                const moveDistance = distance * movePercentage;
                
                const normX = dirX / distance;
                const normY = dirY / distance;
                
                targetViewX += normX * moveDistance;
                targetViewY += normY * moveDistance;
                
                if (currentArea) {
                    const zoomFactor = map(pathCounts[currentArea].count, 0, pathCounts[currentArea].maxCount, 0, 0.2);
                    targetViewX = lerp(targetViewX, area.center.x, zoomFactor);
                    targetViewY = lerp(targetViewY, area.center.y, zoomFactor);
                }
            }
        }
        
        function navigateToCenter() {
            const dirX = initialViewX - targetViewX;
            const dirY = initialViewY - targetViewY;
            
            const distance = sqrt(dirX * dirX + dirY * dirY);
            
            if (distance > 0) {
                const movePercentage = map(distance, 0, width * 2, 0.1, 0.3);
                const moveDistance = distance * movePercentage;
                
                const normX = dirX / distance;
                const normY = dirY / distance;
                
                targetViewX += normX * moveDistance;
                targetViewY += normY * moveDistance;
            }
        }
        
        function resetAllNodes() {
            for (let node of nodes) {
                node.targetActiveTransition = 1.0;
                node.targetScale = 1.0;
                
                if (node.nodeType === "sensory") {
                    node.color = color(
                        red(color(node.pathColor)),
                        green(color(node.pathColor)),
                        blue(color(node.pathColor)),
                        200
                    );
                }
            }
        }
        
        function mousePressed() {
            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                
                if (node.nodeType === "sensory") {
                    selectedPath = node.pathId;
                    selectedNode = hoveredNode;
                    
                    currentArea = node.mainNodeId;
                    
                    if (pathCounts[currentArea].count < pathCounts[currentArea].maxCount) {
                        pathCounts[currentArea].count += 0.5;
                        pathCounts[currentArea][node.pathType] += 0.5;
                        
                        // Restar puntos de otros caminos
                        const otherPathTypes = ["claro", "saturado", "oscuro"].filter(type => type !== node.pathType);
                        otherPathTypes.forEach(type => {
                            pathCounts[currentArea][type] = Math.max(0, pathCounts[currentArea][type] - 0.25);
                        });
                        
                        saveCountersToStorage();
                        updateCounterDisplay();
                    }
                    
                    updateNodeVisibility(node.pathType);
                    navigateToThematicArea(node.thematicArea);
                } 
                else if (node.nodeType === "neutral") {
                    selectedPath = null;
                    selectedNode = null;
                    
                    if (currentArea) {
                        pathCounts[currentArea].count = Math.max(0, pathCounts[currentArea].count - 0.5);
                        
                        pathCounts[currentArea].claro = Math.max(0, pathCounts[currentArea].claro - 0.25);
                        pathCounts[currentArea].saturado = Math.max(0, pathCounts[currentArea].saturado - 0.25);
                        pathCounts[currentArea].oscuro = Math.max(0, pathCounts[currentArea].oscuro - 0.25);
                        
                        // Restaurar el número de nodos al valor inicial
                        currentNodesPerPath = INITIAL_NODES_PER_PATH;
                        
                        // Eliminar nodos adicionales y restaurar los que faltan
                        const currentNodes = nodes.filter(n => 
                            n.nodeType === "sensory" && 
                            n.mainNodeId === currentArea && 
                            n.pathType === selectedPath
                        ).length;
                        
                        if (currentNodes > currentNodesPerPath) {
                            // Eliminar nodos adicionales
                            const nodesToRemove = currentNodes - currentNodesPerPath;
                            const nodesToDelete = nodes.filter(n => 
                                n.nodeType === "sensory" && 
                                n.mainNodeId === currentArea && 
                                n.pathType === selectedPath
                            ).slice(-nodesToRemove);
                            
                            nodesToDelete.forEach(nodeToDelete => {
                                const index = nodes.indexOf(nodeToDelete);
                                if (index > -1) {
                                    nodes.splice(index, 1);
                                    // Actualizar índices en los enlaces
                                    for (let link of links) {
                                        if (link.source > index) link.source--;
                                        if (link.target > index) link.target--;
                                    }
                                }
                            });
                        }
                        
                        saveCountersToStorage();
                        updateCounterDisplay();
                        hideAllMotherNodes();
                    }
                    
                    if (currentArea && pathCounts[currentArea].count === 0) {
                        currentArea = null;
                    }
                    
                    resetAllNodes();
                    navigateToCenter();
                }
                return false;
            }
        }

        function generateNewNode(areaId, pathType, sourceNode) {
            const area = thematicAreas.find(a => a.id === areaId);
            if (!area) return;
            
            const paths = sensoryPaths[areaId];
            const path = paths.find(p => p.id.includes(pathType));
            if (!path) return;
            
            const angle = random(TWO_PI);
            const distance = random(50, 150);
            const x = sourceNode.x + cos(angle) * distance;
            const y = sourceNode.y + sin(angle) * distance;
            
            const distanceFactor = 0.7;
            
            const sectionIndex = floor(random(3));
            const texture = path.textures[min(sectionIndex, path.textures.length - 1)];
            const nodeSound = path.sounds[min(sectionIndex, path.sounds.length - 1)];
            const word = path.words[floor(random(path.words.length))];
            const nodeColor = path.colors[min(sectionIndex, path.colors.length - 1)];
            
            // Obtener el ritmo del array de ritmos
            const rhythm = path.rhythms && path.rhythms.length > 0 ? path.rhythms[0] : "constante";
            const validatedRhythm = validateRhythm(rhythm);
            
            const nodeUniqueId = Date.now() + floor(random(1000));
            
            let mediaType = null;
            let mediaUrl = null;
            let mediaCaption = null;
            
            const hasMedia = random() < 0.7;
            
            if (hasMedia) {
                // Crear array con los tipos de media disponibles
                const availableMediaTypes = [];
                if (path.images.length > 0) availableMediaTypes.push(0);
                if (path.videos.length > 0) availableMediaTypes.push(1);
                if (path.gifs.length > 0) availableMediaTypes.push(2);
                if (path.audios.length > 0) availableMediaTypes.push(3);

                // Si hay tipos de media disponibles
                if (availableMediaTypes.length > 0) {
                    // Seleccionar un tipo aleatorio de los disponibles
                    const randomIndex = floor(random(availableMediaTypes.length));
                    const mediaTypeSelector = availableMediaTypes[randomIndex];

                    if (mediaTypeSelector === 0) {
                        mediaType = "image";
                        const mediaIndex = floor(random(path.images.length));
                        mediaUrl = path.images[mediaIndex].url;
                        mediaCaption = path.images[mediaIndex].caption;
                    } else if (mediaTypeSelector === 1) {
                        mediaType = "video";
                        const mediaIndex = floor(random(path.videos.length));
                        mediaUrl = path.videos[mediaIndex].url;
                        mediaCaption = path.videos[mediaIndex].caption;
                    } else if (mediaTypeSelector === 2) {
                        mediaType = "gif";
                        const mediaIndex = floor(random(path.gifs.length));
                        mediaUrl = path.gifs[mediaIndex].url;
                        mediaCaption = path.gifs[mediaIndex].caption;
                    } else if (mediaTypeSelector === 3) {
                        mediaType = "audio";
                        const mediaIndex = floor(random(path.audios.length));
                        mediaUrl = path.audios[mediaIndex].url;
                        mediaCaption = path.audios[mediaIndex].caption;
                    }
                }
            }
            
            const newNode = {
                x: x,
                y: y,
                baseX: x,
                baseY: y,
                vx: 0,
                vy: 0,
                radius: random(12, 18),
                color: color(
                    red(color(nodeColor)) * distanceFactor,
                    green(color(nodeColor)) * distanceFactor,
                    blue(color(nodeColor)) * distanceFactor,
                    200
                ),
                nodeType: "sensory",
                pathId: path.id,
                pathType: pathType,
                mainNodeId: areaId,
                thematicArea: thematicAreas.findIndex(a => a.id === areaId),
                name: `${path.name} - Nodo Nuevo`,
                noiseOffsetX: random(1000),
                noiseOffsetY: random(1000),
                noiseScale: random(0.01, 0.03),
                screenX: 0,
                screenY: 0,
                visible: true,
                active: true,
                activeTransition: 0.0,
                targetActiveTransition: 1.0,
                labelOpacity: 0,
                scale: 0.1,
                targetScale: 1.0,
                pulseOffset: random(TWO_PI),
                texture: texture,
                sound: nodeSound,
                word: word,
                rhythm: validatedRhythm,
                pathColor: nodeColor,
                distanceFactor: distanceFactor,
                transitionOffsetX: random(-5, 5),
                transitionOffsetY: random(-5, 5),
                nodeUniqueId: nodeUniqueId,
                mediaType: mediaType,
                mediaUrl: mediaUrl,
                mediaCaption: mediaCaption
            };
            
            nodes.push(newNode);
            
            createLinksForNewNode(nodes.length - 1);
        }

        function createLinksForNewNode(nodeIndex) {
            const newNode = nodes[nodeIndex];
            
            if (newNode.nodeType !== "sensory") return;
            
            for (let i = 0; i < nodes.length; i++) {
                if (i === nodeIndex) continue;
                
                const otherNode = nodes[i];
                if (otherNode.nodeType === "sensory" && otherNode.pathId === newNode.pathId) {
                    const dist = distance2D(
                        newNode.x, newNode.y,
                        otherNode.x, otherNode.y
                    );
                    
                    const maxDist = min(width, height) * 0.5;
                    if (dist < maxDist && random() < (1 - dist/maxDist) * 0.6) {
                        links.push({
                            source: nodeIndex,
                            target: i,
                            pathId: newNode.pathId,
                            points: generateIntermediatePoints2D(
                                newNode.x, newNode.y,
                                otherNode.x, otherNode.y,
                                floor(random(1, 3))
                            ),
                            velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                x: random(-0.1, 0.1),
                                y: random(-0.1, 0.1)
                            })),
                            color: newNode.color,
                            opacity: random(0.5, 0.8),
                            pulseRate: random(0.001, 0.005),
                            pulseAmount: random(0.1, 0.3)
                        });
                    }
                }
            }
        }

        window.addEventListener('beforeunload', function() {
            stopAudio();
        });

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>
