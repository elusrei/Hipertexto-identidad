<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todos los Nodos - Visualización Temática 2D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            text-decoration: none;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        .info-panel h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #node-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">Volver al Inicio</a>
    
    <div class="info-panel">
        <h2>Todos los Nodos</h2>
        <p>Visualización 2D de nodos temáticos. Haz clic en los nodos para navegar hacia las diferentes áreas temáticas. Los nodos grises te llevan al centro.</p>
    </div>

    <div id="node-info">Mueve el cursor sobre un nodo para ver información</div>

    <script>
        // Configuración general
        const TOTAL_NODES = 800; // Aumentado de 500 a 800
        const THEMED_NODES_PER_AREA = 80; // Aumentado de 50 a 80
        const NEUTRAL_NODES = TOTAL_NODES - (THEMED_NODES_PER_AREA * 3); // Nodos neutros
        
        // Variables para la cámara/vista
        let viewX = 0;
        let viewY = 0;
        let targetViewX = 0;
        let targetViewY = 0;
        let initialViewX = 0; // Posición inicial (centro)
        let initialViewY = 0; // Posición inicial (centro)
        
        // Variables para interacción
        let hoveredNode = null;
        let selectedNode = null;
        let hoverScale = 1.0; // Escala para efecto hover
        let hoverTargetScale = 1.0; // Escala objetivo para efecto hover
        
        // Arreglos para almacenar nodos y enlaces
        const nodes = [];
        const links = [];
        
        // Variable para el elemento de información del nodo
        let nodeInfo;
        
        // Áreas temáticas (centros y colores)
        let thematicAreas = [];
        
        // Variables para efectos visuales
        let noiseOffset = 0;
        let globalTime = 0;
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1); // Para mejor rendimiento
            
            // Inicializar offset de ruido
            noiseOffset = random(1000);
            
            // Definir áreas temáticas con colores
            // Distribuidas en un área 4 veces más grande que la pantalla
            const worldWidth = width * 4;
            const worldHeight = height * 4;
            
            thematicAreas = [
                { 
                    name: "Área Temática 1", 
                    center: { x: worldWidth * 0.25, y: worldHeight * 0.25 }, 
                    color: color(255, 100, 100) // Rojo
                },
                { 
                    name: "Área Temática 2", 
                    center: { x: worldWidth * 0.75, y: worldHeight * 0.25 }, 
                    color: color(100, 255, 100) // Verde
                },
                { 
                    name: "Área Temática 3", 
                    center: { x: worldWidth * 0.5, y: worldHeight * 0.75 }, 
                    color: color(100, 100, 255) // Azul
                }
            ];
            
            // Establecer el centro del mundo como posición inicial
            initialViewX = worldWidth * 0.5;
            initialViewY = worldHeight * 0.5;
            
            // Centrar la vista inicialmente
            targetViewX = initialViewX;
            targetViewY = initialViewY;
            
            // Crear nodos temáticos
            for (let areaIndex = 0; areaIndex < thematicAreas.length; areaIndex++) {
                const area = thematicAreas[areaIndex];
                
                for (let i = 0; i < THEMED_NODES_PER_AREA; i++) {
                    // Calcular distancia desde el centro del área (más nodos cerca del centro)
                    // Usar distribución exponencial para concentrar nodos cerca del centro
                    const distanceFactor = pow(random(), 1.5); // Exponencial para concentrar cerca del centro
                    const maxDistance = min(width, height) * 2.0; // Aumentado para mayor dispersión
                    const distance = distanceFactor * maxDistance;
                    
                    // Posición aleatoria en círculo alrededor del centro del área
                    const angle = random(TWO_PI);
                    const x = area.center.x + cos(angle) * distance;
                    const y = area.center.y + sin(angle) * distance;
                    
                    // Calcular intensidad de color basada en la distancia al centro
                    // Nodos más cercanos al centro tienen color más intenso
                    const colorIntensity = map(distanceFactor, 0, 1, 1, 0.5);
                    const nodeColor = color(
                        red(area.color) * colorIntensity,
                        green(area.color) * colorIntensity,
                        blue(area.color) * colorIntensity,
                        200
                    );
                    
                    // Crear nodo
                    nodes.push({
                        x: x,
                        y: y,
                        baseX: x, // Posición base para mantener dentro del área
                        baseY: y,
                        vx: 0,
                        vy: 0,
                        radius: random(12, 22), // Tamaño variable
                        color: nodeColor,
                        thematicArea: areaIndex, // Índice del área temática
                        name: `${area.name} - Nodo ${i+1}`,
                        noiseOffsetX: random(1000),
                        noiseOffsetY: random(1000),
                        noiseScale: random(0.01, 0.04), // Aumentado para más movimiento
                        screenX: 0,
                        screenY: 0,
                        visible: true,
                        labelOpacity: 0,
                        scale: 1.0, // Escala para animación
                        targetScale: 1.0, // Escala objetivo
                        pulseOffset: random(TWO_PI) // Offset para efecto de pulso
                    });
                }
            }
            
            // Crear nodos neutros (grises)
            for (let i = 0; i < NEUTRAL_NODES; i++) {
                // Distribución en un área 4 veces más grande que la pantalla
                const x = random(0, width * 4);
                const y = random(0, height * 4);
                
                // Color gris con variación
                const grayValue = random(100, 180);
                const nodeColor = color(grayValue, grayValue, grayValue, 180);
                
                // Crear nodo
                nodes.push({
                    x: x,
                    y: y,
                    baseX: x,
                    baseY: y,
                    vx: 0,
                    vy: 0,
                    radius: random(5, 15), // Más pequeños que los temáticos
                    color: nodeColor,
                    thematicArea: -1, // -1 indica nodo neutro
                    name: `Nodo Neutro ${i+1}`,
                    noiseOffsetX: random(1000),
                    noiseOffsetY: random(1000),
                    noiseScale: random(0.01, 0.03),
                    screenX: 0,
                    screenY: 0,
                    visible: true,
                    labelOpacity: 0,
                    scale: 1.0,
                    targetScale: 1.0,
                    pulseOffset: random(TWO_PI)
                });
            }
            
            // Crear enlaces entre nodos
            createLinks();
            
            // Obtener el elemento para mostrar información del nodo
            nodeInfo = select('#node-info');
        }
        
        function createLinks() {
            // Crear enlaces entre nodos temáticos de la misma área
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].thematicArea >= 0) { // Si es un nodo temático
                    // Buscar otros nodos de la misma área temática
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].thematicArea === nodes[i].thematicArea) {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con cierta probabilidad
                            // Mayor probabilidad para nodos cercanos
                            const maxDist = min(width, height) * 0.8; // Aumentado para más conexiones
                            if (dist < maxDist && random() < (1 - dist/maxDist) * 0.4) { // Aumentada probabilidad
                                links.push({
                                    source: i,
                                    target: j,
                                    // Puntos intermedios para crear líneas orgánicas
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 4)) // 1-3 puntos intermedios
                                    ),
                                    // Velocidades para movimiento sutil
                                    velocities: Array(floor(random(1, 4))).fill().map(() => ({
                                        x: random(-0.1, 0.1), // Aumentado para más movimiento
                                        y: random(-0.1, 0.1)
                                    })),
                                    color: nodes[i].color, // Color basado en el área temática
                                    opacity: random(0.5, 0.8),
                                    pulseRate: random(0.001, 0.005), // Velocidad de pulso
                                    pulseAmount: random(0.1, 0.3) // Cantidad de pulso
                                });
                            }
                        }
                    }
                }
            }
            
            // Crear algunos enlaces entre nodos neutros
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].thematicArea === -1) { // Si es un nodo neutro
                    // Buscar otros nodos neutros cercanos
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].thematicArea === -1) {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con baja probabilidad
                            const maxDist = min(width, height) * 0.5; // Aumentado
                            if (dist < maxDist && random() < 0.08) { // Aumentada probabilidad
                                links.push({
                                    source: i,
                                    target: j,
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 3))
                                    ),
                                    velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                        x: random(-0.08, 0.08),
                                        y: random(-0.08, 0.08)
                                    })),
                                    color: color(150, 150, 150, 100), // Gris para nodos neutros
                                    opacity: random(0.3, 0.5),
                                    pulseRate: random(0.001, 0.003),
                                    pulseAmount: random(0.1, 0.2)
                                });
                            }
                        }
                    }
                }
            }
            
            // Crear algunos enlaces entre nodos temáticos y neutros
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].thematicArea >= 0) { // Si es un nodo temático
                    // Buscar nodos neutros cercanos
                    for (let j = 0; j < nodes.length; j++) {
                        if (nodes[j].thematicArea === -1) {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con baja probabilidad
                            const maxDist = min(width, height) * 0.6; // Aumentado
                            if (dist < maxDist && random() < 0.03) { // Aumentada probabilidad
                                links.push({
                                    source: i,
                                    target: j,
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 3))
                                    ),
                                    velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                        x: random(-0.08, 0.08),
                                        y: random(-0.08, 0.08)
                                    })),
                                    // Color mezclado entre temático y neutro
                                    color: lerpColor(
                                        nodes[i].color, 
                                        color(150, 150, 150), 
                                        0.5
                                    ),
                                    opacity: random(0.3, 0.6),
                                    pulseRate: random(0.001, 0.004),
                                    pulseAmount: random(0.1, 0.25)
                                });
                            }
                        }
                    }
                }
            }
            
            // Crear algunos enlaces adicionales entre áreas temáticas diferentes
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].thematicArea >= 0) { // Si es un nodo temático
                    // Buscar nodos de otras áreas temáticas
                    for (let j = 0; j < nodes.length; j++) {
                        if (nodes[j].thematicArea >= 0 && nodes[j].thematicArea !== nodes[i].thematicArea) {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con muy baja probabilidad
                            const maxDist = min(width, height) * 0.7;
                            if (dist < maxDist && random() < 0.01) {
                                // Color mezclado entre las dos áreas temáticas
                                const mixedColor = lerpColor(
                                    nodes[i].color, 
                                    nodes[j].color, 
                                    0.5
                                );
                                
                                links.push({
                                    source: i,
                                    target: j,
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(2, 4)) // Más puntos para líneas más orgánicas
                                    ),
                                    velocities: Array(floor(random(2, 4))).fill().map(() => ({
                                        x: random(-0.1, 0.1),
                                        y: random(-0.1, 0.1)
                                    })),
                                    color: mixedColor,
                                    opacity: random(0.4, 0.7),
                                    pulseRate: random(0.002, 0.005),
                                    pulseAmount: random(0.15, 0.3)
                                });
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            background(0); // Fondo negro
            
            // Incrementar tiempo global
            globalTime += 0.01;
            
            // Incrementar offset de ruido
            noiseOffset += 0.005;
            
            // Actualizar posición de la vista con suavizado
            viewX = lerp(viewX, targetViewX, 0.05);
            viewY = lerp(viewY, targetViewY, 0.05);
            
            // Aplicar transformación para la vista
            translate(width/2 - viewX, height/2 - viewY);
            
            // Actualizar posiciones en pantalla de los nodos
            updateScreenPositions();
            
            // Verificar si el mouse está sobre algún nodo
            checkMouseOverNodes();
            
            // Dibujar enlaces
            drawLinks();
            
            // Dibujar nodos
            drawNodes();
            
            // Actualizar posiciones de los nodos con movimiento orgánico
            updateNodePositions();
            
            // Información en pantalla (fuera de la transformación)
            resetMatrix();
            updateNodeInfo();
        }
        
        function drawLinks() {
            for (const link of links) {
                const source = nodes[link.source];
                const target = nodes[link.target];
                
                // Solo dibujar si ambos nodos son visibles
                if (source.visible && target.visible) {
                    // Calcular opacidad con efecto de pulso
                    const pulseEffect = sin(globalTime * link.pulseRate * TWO_PI) * link.pulseAmount + 1;
                    const currentOpacity = link.opacity * pulseEffect;
                    
                    // Establecer color y opacidad
                    stroke(
                        red(link.color), 
                        green(link.color), 
                        blue(link.color), 
                        alpha(link.color) * currentOpacity
                    );
                    strokeWeight(1);
                    
                    // Dibujar línea orgánica en 2D
                    drawOrganicLine2D(
                        source.x, source.y,
                        target.x, target.y,
                        link.points
                    );
                    
                    // Actualizar posiciones de los puntos intermedios
                    updateLinkPoints(link);
                }
            }
        }
        
        function drawNodes() {
            noStroke();
            
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                if (node.visible) {
                    // Actualizar escala con suavizado
                    node.scale = lerp(node.scale, node.targetScale, 0.2);
                    
                    // Efecto de pulso sutil para todos los nodos
                    const pulseEffect = sin(globalTime * 0.5 + node.pulseOffset) * 0.05 + 1;
                    const currentScale = node.scale * pulseEffect;
                    
                    // Efecto de bloom (varias capas con diferentes tamaños y opacidades)
                    for (let j = 3; j > 0; j--) {
                        // Nodo seleccionado o hover: más brillante
                        if (selectedNode === i || hoveredNode === i) {
                            fill(
                                min(red(node.color) + 70, 255),
                                min(green(node.color) + 70, 255),
                                min(blue(node.color) + 70, 255),
                                60 / j // Mayor opacidad para el bloom
                            );
                        } else {
                            fill(red(node.color), green(node.color), blue(node.color), 50 / j);
                        }
                        circle(node.x, node.y, node.radius * 2 * j * currentScale);
                    }
                    
                    // Nodo principal
                    if (selectedNode === i || hoveredNode === i) {
                        fill(
                            min(red(node.color) + 70, 255),
                            min(green(node.color) + 70, 255),
                            min(blue(node.color) + 70, 255),
                            230
                        );
                    } else {
                        fill(red(node.color), green(node.color), blue(node.color), 200);
                    }
                    circle(node.x, node.y, node.radius * 2 * currentScale);
                    
                    // Dibujar texto del nodo si está seleccionado o hover
                    if (selectedNode === i || hoveredNode === i) {
                        fill(255, 255, 255, 230);
                        textAlign(CENTER, CENTER);
                        textSize(12);
                        // Dibujar texto encima del nodo
                        text(node.name, node.x, node.y - node.radius * currentScale - 10);
                    }
                }
            }
        }
        
        function updateNodePositions() {
            for (let node of nodes) {
                // Calcular nuevas velocidades basadas en ruido Perlin
                const time = frameCount * 0.01;
                const noiseX = noise(node.noiseOffsetX + time) * 2 - 1;
                const noiseY = noise(node.noiseOffsetY + time) * 2 - 1;
                
                // Aplicar suavizado a los cambios de velocidad
                node.vx = lerp(node.vx, noiseX * node.noiseScale * 2, 0.02);
                node.vy = lerp(node.vy, noiseY * node.noiseScale * 2, 0.02);
                
                // Actualizar posición
                node.x += node.vx;
                node.y += node.vy;
                
                // Mantener cerca de la posición base con fuerza suave
                node.x += (node.baseX - node.x) * 0.01;
                node.y += (node.baseY - node.y) * 0.01;
                
                // Actualizar escala objetivo basada en hover
                if (hoveredNode === nodes.indexOf(node)) {
                    node.targetScale = 1.3; // Agrandar al hacer hover
                } else {
                    node.targetScale = 1.0; // Tamaño normal
                }
            }
        }
        
        // Función para actualizar las posiciones de los puntos intermedios de los enlaces
        function updateLinkPoints(link) {
            if (!link.points || !link.velocities || link.points.length !== link.velocities.length) {
                return; // Evitar errores si los arrays no coinciden
            }
            
            for (let i = 0; i < link.points.length; i++) {
                const point = link.points[i];
                const velocity = link.velocities[i];
                
                // Actualizar posición con velocidad
                point.x += velocity.x;
                point.y += velocity.y;
                
                // Calcular posición base (punto en la línea recta entre origen y destino)
                const t = (i + 1) / (link.points.length + 1);
                const sourceX = nodes[link.source].x;
                const sourceY = nodes[link.source].y;
                const targetX = nodes[link.target].x;
                const targetY = nodes[link.target].y;
                
                const baseX = sourceX + (targetX - sourceX) * t;
                const baseY = sourceY + (targetY - sourceY) * t;
                
                // Mantener el punto cerca de su posición base
                point.x += (baseX - point.x) * 0.02;
                point.y += (baseY - point.y) * 0.02;
            }
        }
        
        // Función para actualizar las posiciones en pantalla de los nodos
        function updateScreenPositions() {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                // Calcular posición en pantalla
                node.screenX = node.x - viewX + width/2;
                node.screenY = node.y - viewY + height/2;
                
                // Verificar si está dentro de la pantalla (con margen)
                const margin = node.radius * 3;
                node.visible = 
                    node.screenX + margin >= 0 && 
                    node.screenX - margin <= width && 
                    node.screenY + margin >= 0 && 
                    node.screenY - margin <= height;
            }
        }
        
        // Función para verificar si el mouse está sobre algún nodo
        function checkMouseOverNodes() {
            // Resetear hover
            hoveredNode = null;
            
            // Verificar todos los nodos
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                // Solo verificar nodos visibles
                if (node.visible) {
                    const distance = dist(mouseX, mouseY, node.screenX, node.screenY);
                    
                    if (distance < node.radius * node.scale) {
                        hoveredNode = i;
                        break; // Tomar solo el primer nodo encontrado
                    }
                }
            }
        }
        
        // Función para actualizar la información del nodo
        function updateNodeInfo() {
            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                let infoText = `${node.name}`;
                
                if (node.thematicArea >= 0) {
                    infoText += ` - Haz clic para navegar hacia ${thematicAreas[node.thematicArea].name}`;
                } else {
                    infoText += " - Haz clic para volver al centro";
                }
                
                nodeInfo.html(infoText);
            } else {
                nodeInfo.html("Mueve el cursor sobre un nodo para ver información");
            }
        }
        
        // Función para generar puntos intermedios para líneas orgánicas en 2D
        function generateIntermediatePoints2D(x1, y1, x2, y2, numPoints) {
            const points = [];
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                
                // Línea base
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                // Vector dirección
                const dirX = x2 - x1;
                const dirY = y2 - y1;
                
                // Vector perpendicular
                const perpX = -dirY;
                const perpY = dirX;
                
                // Normalizar
                const perpLength = sqrt(perpX * perpX + perpY * perpY);
                let normPerpX = 0;
                let normPerpY = 0;
                
                if (perpLength > 0) {
                    normPerpX = perpX / perpLength;
                    normPerpY = perpY / perpLength;
                }
                
                // Aplicar desviación
                const deviation = random(-30, 30); // Aumentado para más curvatura
                
                points.push({
                    x: baseX + normPerpX * deviation,
                    y: baseY + normPerpY * deviation
                });
            }
            
            return points;
        }
        
        // Función para dibujar línea orgánica/quebrada en 2D
        function drawOrganicLine2D(x1, y1, x2, y2, points) {
            noFill();
            beginShape();
            vertex(x1, y1);
            
            for (const point of points) {
                vertex(point.x, point.y);
            }
            
            vertex(x2, y2);
            endShape();
        }
        
        // Función auxiliar para calcular distancia en 2D
        function distance2D(x1, y1, x2, y2) {
            return sqrt(
                (x2 - x1) * (x2 - x1) + 
                (y2 - y1) * (y2 - y1)
            );
        }
        
        // Función para navegar hacia un área temática
        function navigateToThematicArea(areaIndex) {
            const area = thematicAreas[areaIndex];
            
            // Calcular vector desde la posición actual hacia el área
            const dirX = area.center.x - targetViewX;
            const dirY = area.center.y - targetViewY;
            
            // Calcular distancia
            const distance = sqrt(dirX * dirX + dirY * dirY);
            
            if (distance > 0) {
                // Mover un porcentaje hacia el área (movimiento gradual)
                // Cuanto más lejos, mayor el movimiento
                const movePercentage = map(distance, 0, width * 2, 0.1, 0.3);
                const moveDistance = distance * movePercentage;
                
                // Normalizar el vector
                const normX = dirX / distance;
                const normY = dirY / distance;
                
                // Actualizar posición objetivo
                targetViewX += normX * moveDistance;
                targetViewY += normY * moveDistance;
            }
        }
        
        // Función para navegar hacia el centro
        function navigateToCenter() {
            // Calcular vector desde la posición actual hacia el centro
            const dirX = initialViewX - targetViewX;
            const dirY = initialViewY - targetViewY;
            
            // Calcular distancia
            const distance = sqrt(dirX * dirX + dirY * dirY);
            
            if (distance > 0) {
                // Mover un porcentaje hacia el centro (movimiento gradual)
                const movePercentage = map(distance, 0, width * 2, 0.1, 0.3);
                const moveDistance = distance * movePercentage;
                
                // Normalizar el vector
                const normX = dirX / distance;
                const normY = dirY / distance;
                
                // Actualizar posición objetivo
                targetViewX += normX * moveDistance;
                targetViewY += normY * moveDistance;
            }
        }
        
        function mousePressed() {
            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                
                // Si es un nodo temático, navegar hacia su área
                if (node.thematicArea >= 0) {
                    navigateToThematicArea(node.thematicArea);
                    selectedNode = hoveredNode;
                } else {
                    // Si es un nodo neutro, navegar hacia el centro
                    navigateToCenter();
                    selectedNode = hoveredNode;
                }
                return false; // Prevenir comportamiento predeterminado
            }
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>