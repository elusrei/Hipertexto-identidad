<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todos los Nodos - Visualización Temática Sensorial</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            text-decoration: none;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        .info-panel h2 {
            margin-top: 0;
            font-size: 20px;
        }
        #node-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #path-counters {
            position: absolute;
            top: 60px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .counter-bar {
            height: 15px;
            margin: 5px 0;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        .counter-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        .counter-fill.red {
            background-color: #FF5555;
        }
        .counter-fill.green {
            background-color: #55FF55;
        }
        .counter-fill.blue {
            background-color: #5555FF;
        }
        .mother-node {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.3) 70%, rgba(255,255,255,0) 100%);
            cursor: pointer;
            z-index: 200;
            display: none;
            animation: pulse 2s infinite;
            box-shadow: 0 0 20px 10px rgba(255,255,255,0.5);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px 10px rgba(255,255,255,0.5);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 30px 15px rgba(255,255,255,0.7);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px 10px rgba(255,255,255,0.5);
            }
        }
        .media-panel {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.8);
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    z-index: 300;
    max-width: 300px;
    max-height: 300px;
    display: none;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.media-panel img, .media-panel video {
    max-width: 100%;
    max-height: 280px;
    border-radius: 4px;
}

.media-panel .media-caption {
    color: white;
    font-size: 14px;
    margin-top: 8px;
    text-align: center;
}
    </style>
</head>
<body>
    <a href="index.html" class="back-button">Volver al Inicio</a>
    
    <div class="info-panel">
        <h2>Todos los Nodos</h2>
        <p>Visualización de nodos temáticos sensoriales. Haz clic en los nodos para navegar hacia las diferentes experiencias sensoriales. Los nodos grises te llevan al centro.</p>
    </div>

    <div id="node-info">Mueve el cursor sobre un nodo para ver información</div>
    
    <div id="path-counters">
        <h3>Progreso de Caminos</h3>
        <div>
            <span>Rojo:</span>
            <div class="counter-bar">
                <div class="counter-fill red" id="red-counter"></div>
            </div>
        </div>
        <div>
            <span>Verde:</span>
            <div class="counter-bar">
                <div class="counter-fill green" id="green-counter"></div>
            </div>
        </div>
        <div>
            <span>Azul:</span>
            <div class="counter-bar">
                <div class="counter-fill blue" id="blue-counter"></div>
            </div>
        </div>
    </div>
    
    <div id="media-panel" class="media-panel">
    <div id="media-content"></div>
    <div id="media-caption" class="media-caption"></div>
</div>
    
    <!-- Nodos nodriza para cada área temática -->
    <div class="mother-node" id="mother-node-aranias" onclick="openExperience('aranias')"></div>
    <div class="mother-node" id="mother-node-feliz" onclick="openExperience('feliz')"></div>
    <div class="mother-node" id="mother-node-triste" onclick="openExperience('triste')"></div>

    <script>
        // Función para seleccionar un recurso aleatorio de un array
function getRandomResource(resourceArray) {
    if (!resourceArray || resourceArray.length === 0) {
        return null;
    }
    return resourceArray[Math.floor(random(resourceArray.length))];
}
        // Configuración general
        const TOTAL_NODES = 900; // Reducido de 1200 a 900
        const NODES_PER_PATH = 30; // Reducido de 40 a 30
        const NEUTRAL_NODES = TOTAL_NODES - (NODES_PER_PATH * 9);
        
        // Variables para la cámara/vista
        let viewX = 0;
        let viewY = 0;
        let targetViewX = 0;
        let targetViewY = 0;
        let initialViewX = 0;
        let initialViewY = 0;
        
        // Variables para interacción
        let hoveredNode = null;
        let selectedNode = null;
        let selectedPath = null;
        let hoverScale = 1.0;
        let hoverTargetScale = 1.0;
        
        // Arreglos para almacenar nodos y enlaces
        const nodes = [];
        const links = [];
        
        // Variable para el elemento de información del nodo
        let nodeInfo;
        let pathCounters;
        let motherNodes = {};
        
        // Contadores de caminos para cada área temática
        let pathCounts = {
    aranias: { 
        count: 0, 
        maxCount: 10,
        rojo: 0,
        verde: 0,
        azul: 0
    },
    feliz: { 
        count: 0, 
        maxCount: 10,
        rojo: 0,
        verde: 0,
        azul: 0
    },
    triste: { 
        count: 0, 
        maxCount: 10,
        rojo: 0,
        verde: 0,
        azul: 0
    }
};
        
        // Área temática actualmente seleccionada
        let currentArea = null;
        
        // Modificar la sección donde se definen las rutas sensoriales para incluir arrays de recursos multimedia
// Reemplazar la sección de definición de sensoryPaths con esta versión actualizada:

// Reemplazar la definición de sensoryPaths con la versión proporcionada por el user
const sensoryPaths = {
    aranias: [
        {
            id: "aranias_rojo",
            name: "Camino Rojo - Arañas",
            textures: ["muchas_lineas", "lineas_entrecruzadas", "tela_araña"],
            sounds: ["alarma_punzante", "zumbido_agudo", "chasquidos"],
            words: ["peligro", "alerta", "cuidado", "advertencia", "amenaza"],
            colors: ["#FF0000", "#CC0000", "#990000"], // Tonos de rojo
            rhythm: "pulso_constante",
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "arañas/araña-1.gif", caption: "GIF sensorial rojo 1" }
            ],
            audios: [
                
            ]
        },
        {
            id: "aranias_verde",
            name: "Camino Verde - Arañas",
            textures: ["lineas_que_se_acercan", "estructuras_3d", "entramados"],
            sounds: ["wosh_estilo_jumpscare", "susurro_acercandose", "crujidos"],
            words: ["trampa", "emboscada", "enredo", "captura", "cazador"],
            colors: ["#00FF00", "#00CC00", "#009900"], // Tonos de verde
            rhythm: "iiiiiiiiiiiiiiiiiiiiiip", // Ritmo entrecortado o irregular
           // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "arañas/araña-1.gif", caption: "GIF sensorial rojo 1" }
            ],
            audios: [
                
            ]
        },
        {
            id: "aranias_azul",
            name: "Camino Azul - Arañas",
            textures: ["menos_lineas", "rotas", "endebles"],
            sounds: ["pad_tranquilo", "ambiente_suave", "goteo"],
            words: ["observación", "paciencia", "espera", "estrategia", "sigilo", "plan", "táctica", "inteligencia"],
            colors: ["#0000FF", "#0000CC", "#000099"], // Tonos de azul
            rhythm: "oscilacion_lenta",
            // Arrays de recursos multimedia
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "arañas/araña-1.gif", caption: "GIF sensorial rojo 1" }
            ],
            audios: [
                
            ]
        }
    ],
    feliz: [
        {
            id: "feliz_rojo",
            name: "Camino Rojo - Feliz",
            textures: ["granulado", "vibrante", "texturado"],
            sounds: ["paraguas", "cascabeles", "risas"],
            words: ["éxito", "victoria", "logro", "triunfo", "celebración"],
            colors: ["#FF9999", "#FF6666", "#FF3333"], // Rojo pastel
            rhythm: "desvanece",
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "arañas/araña-1.gif", caption: "GIF sensorial rojo 1" }
            ],
            audios: [
                
            ]
        },
        {
            id: "feliz_verde",
            name: "Camino Verde - Feliz",
            textures: ["mojado", "brillante", "fluido"],
            sounds: ["estadio", "multitud", "aplausos"],
            words: ["energía", "vitalidad", "fuerza", "poder", "impulso"],
            colors: ["#99FF99", "#66FF66", "#33FF33"], // Verde pastel
            rhythm: "constante",
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "arañas/araña-1.gif", caption: "GIF sensorial rojo 1" }
            ],
            audios: [
                
            ]
        },
        {
            id: "feliz_azul",
            name: "Camino Azul - Feliz",
            textures: ["amarillo", "dorado", "luminoso"],
            sounds: ["melodía", "armónico", "musical"],
            words: ["calma", "serenidad", "paz", "tranquilidad", "armonía"],
            colors: ["#9999FF", "#6666FF", "#3333FF"], // Azul pastel
            rhythm: "continuo_suave",
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "arañas/araña-1.gif", caption: "GIF sensorial rojo 1" }
            ],
            audios: [
                
            ]
        }
    ],
    triste: [
        {
            id: "triste_rojo",
            name: "Camino Rojo - Triste",
            textures: ["liso_y_frio", "plano", "simple"],
            sounds: ["lento_y_constante", "monótono", "grave"],
            words: ["pérdida", "ausencia", "vacío", "soledad", "abandono"],
            colors: ["#CC9999", "#BB7777", "#AA5555"], // Rojo apagado
            rhythm: "muy_lento",
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "recuerdo triste/sad.gif", caption: "GIF sensorial rojo 1" }
            ],
            audios: [
                { url: "recuerdo triste/angustia llanto.wav", caption: "Audio triste rojo 1" },
                { url: "recuerdo triste/llanto mas espaciado.wav", caption: "Audio triste rojo 2" }
            ]
        },
        {
            id: "triste_verde",
            name: "Camino Verde - Triste",
            textures: ["humeda", "fría", "brumosa"],
            sounds: ["llanto", "lamento", "suspiro"],
            words: ["melancolía", "nostalgia", "añoranza", "tristeza", "recuerdo"],
            colors: ["#99CC99", "#77BB77", "#55AA55"], // Verde apagado
            rhythm: "gotas_espaciadas",
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "recuerdo triste/sad.gif", caption: "GIF triste verde 1" }
            ],
            audios: [
                { url: "recuerdo triste/angustia llanto.wav", caption: "Audio triste verde 1" },
                { url: "recuerdo triste/llanto mas espaciado.wav", caption: "Audio triste verde 2" }
            ]
        },
        {
            id: "triste_azul",
            name: "Camino Azul - Triste",
            textures: ["pegajosa", "viscosa", "densa"],
            sounds: ["nostalgia", "eco", "distante"],
            words: ["resignación", "aceptación", "rendición", "final", "despedida"],
            colors: ["#9999CC", "#7777BB", "#5555AA"], // Azul apagado
            rhythm: "apagandose",
            // Arrays de recursos multimedia
            images: [
            
            ],
            videos: [
           
            ],
            gifs: [
                { url: "recuerdo triste/sad.gif", caption: "GIF sensorial azul 1" }
            ],
            audios: [
                { url: "recuerdo triste/angustia llanto.wav", caption: "Audio triste azul 1" },
                { url: "recuerdo triste/llanto mas espaciado.wav", caption: "Audio triste azul 2" }
            ]
        }
    ]
};

// Eliminar la sección que añade propiedades de media a las rutas sensoriales, ya que ahora están definidas directamente
// Buscar y eliminar el siguiente bloque:
/*
// Añadir propiedades de media a las rutas sensoriales
for (const areaId in sensoryPaths) {
    for (const path of sensoryPaths[areaId]) {
        // Añadir propiedades de media
        path.images = [];
        path.videos = [];
        path.gifs = [];
        path.audios = [];
        
        // Ejemplos de media para cada camino (puedes personalizar estas rutas)
        if (path.id.includes("rojo")) {
            path.images.push({
                url: "media/" + areaId + "/rojo_imagen1.jpg",
                caption: "Imagen sensorial roja"
            });
            path.videos.push({
                url: "media/" + areaId + "/rojo_video1.mp4",
                caption: "Video sensorial rojo"
            });
            path.audios.push({
                url: "media/" + areaId + "/rojo_audio1.mp3",
                caption: "Audio sensorial rojo"
            });
        } else if (path.id.includes("verde")) {
            path.images.push({
                url: "media/" + areaId + "/verde_imagen1.jpg",
                caption: "Imagen sensorial verde"
            });
            path.gifs.push({
                url: "media/" + areaId + "/verde_gif1.gif",
                caption: "GIF sensorial verde"
            });
            path.audios.push({
                url: "media/" + areaId + "/verde_audio1.mp3",
                caption: "Audio sensorial verde"
            });
        } else if (path.id.includes("azul")) {
            path.images.push({
                url: "media/" + areaId + "/azul_imagen1.jpg",
                caption: "Imagen sensorial azul"
            });
            path.videos.push({
                url: "media/" + areaId + "/azul_video1.mp4",
                caption: "Video sensorial azul"
            });
            path.audios.push({
                url: "media/" + areaId + "/azul_audio1.mp3",
                caption: "Audio sensorial azul"
            });
        }
    }
}
*/
        
        // Variables para almacenar precargas de imágenes
        let textureImages = {};
        
        // Áreas temáticas (centros y colores)
        let thematicAreas = [];
        
        // Variables para efectos visuales
        let noiseOffset = 0;
        let globalTime = 0;

        // Variables para manejo de media
let mediaPanel;
let currentAudio = null;
let audioPlaying = false;
        
        // Cargar contadores desde sessionStorage si existen
        function loadCountersFromStorage() {
            const storedCounts = sessionStorage.getItem('pathCounts');
            if (storedCounts) {
                pathCounts = JSON.parse(storedCounts);
            }
            updateCounterDisplay();
        }
        
        // Guardar contadores en sessionStorage
        function saveCountersToStorage() {
            sessionStorage.setItem('pathCounts', JSON.stringify(pathCounts));
        }
        
        // Update the updateCounterDisplay function
        function updateCounterDisplay() {
    // Si hay un área actual, actualizar su visualización de contador
    if (currentArea) {
        const areaCount = pathCounts[currentArea].count;
        const maxCount = pathCounts[currentArea].maxCount;
        
        // Actualizar las barras de progreso para mostrar el progreso para cada tipo sensorial
        const redCount = pathCounts[currentArea].rojo;
        const greenCount = pathCounts[currentArea].verde;
        const blueCount = pathCounts[currentArea].azul;
        
        // Calcular porcentajes (máximo 100%)
        const redPercentage = Math.min(100, (redCount / (maxCount/3)) * 100);
        const greenPercentage = Math.min(100, (greenCount / (maxCount/3)) * 100);
        const bluePercentage = Math.min(100, (blueCount / (maxCount/3)) * 100);
        
        // Actualizar barras de progreso
        document.getElementById('red-counter').style.width = redPercentage + '%';
        document.getElementById('green-counter').style.width = greenPercentage + '%';
        document.getElementById('blue-counter').style.width = bluePercentage + '%';
        
        // Mostrar el nodo nodriza si el contador alcanza el máximo
        if (areaCount >= maxCount) {
            console.log("Mostrando nodo nodriza para: " + currentArea); // Depuración
            showMotherNode(currentArea);
        } else {
            // Ocultar el nodo nodriza si no hemos alcanzado el máximo
            hideAllMotherNodes();
        }
    } else {
        // Si no hay área seleccionada, mostrar barras vacías
        document.getElementById('red-counter').style.width = '0%';
        document.getElementById('green-counter').style.width = '0%';
        document.getElementById('blue-counter').style.width = '0%';
        
        // Ocultar todos los nodos nodriza
        hideAllMotherNodes();
    }
}
        
        // Mostrar el nodo nodriza específico para un área
        function showMotherNode(areaId) {
    console.log("Intentando mostrar nodo nodriza para: " + areaId); // Depuración
    
    // Ocultar todos los nodos nodriza primero
    hideAllMotherNodes();
    
    // Mostrar el nodo nodriza específico
    const motherNode = document.getElementById(`mother-node-${areaId}`);
    if (motherNode) {
        console.log("Nodo nodriza encontrado, mostrando..."); // Depuración
        
        // Asegurarse de que el nodo sea visible
        motherNode.style.display = 'block';
        motherNode.style.opacity = '1';
        
        // Posicionar en el centro de la pantalla
        motherNode.style.left = (windowWidth / 2 - 30) + 'px';
        motherNode.style.top = (windowHeight / 2 - 30) + 'px';
        
        // Establecer color basado en el área
        let dominantColor = 'white';
        
        if (areaId === 'aranias') {
            dominantColor = '#FF5555'; // Rojo para arañas
            motherNode.style.boxShadow = '0 0 30px 15px rgba(255,85,85,0.7)';
        } else if (areaId === 'feliz') {
            dominantColor = '#55FF55'; // Verde para feliz
            motherNode.style.boxShadow = '0 0 30px 15px rgba(85,255,85,0.7)';
        } else if (areaId === 'triste') {
            dominantColor = '#5555FF'; // Azul para triste
            motherNode.style.boxShadow = '0 0 30px 15px rgba(85,85,255,0.7)';
        }
        
        motherNode.style.background = `radial-gradient(circle, ${dominantColor} 0%, rgba(255,255,255,0.3) 70%, rgba(255,255,255,0) 100%)`;
        
        // Forzar un reflow para asegurar que los cambios se apliquen
        motherNode.offsetHeight;
    } else {
        console.error("No se encontró el nodo nodriza para: " + areaId); // Depuración
    }
}
        
        // Ocultar todos los nodos nodriza
        function hideAllMotherNodes() {
            document.querySelectorAll('.mother-node').forEach(node => {
                node.style.opacity = '0';
                setTimeout(() => {
                    if (node.style.opacity === '0') {
                        node.style.display = 'none';
                    }
                }, 500);
            });
        }
        
        // Update the openExperience function
        function openExperience(areaId) {
    // Determinar qué tipo sensorial fue el más clickeado
    let dominantSensoryType = "rojo"; // Valor predeterminado
    
    if (pathCounts[areaId]) {
        const redCount = pathCounts[areaId].rojo;
        const greenCount = pathCounts[areaId].verde;
        const blueCount = pathCounts[areaId].azul;
        
        // Encontrar el tipo con más clicks
        if (greenCount > redCount && greenCount > blueCount) {
            dominantSensoryType = "verde";
        } else if (blueCount > redCount && blueCount > greenCount) {
            dominantSensoryType = "azul";
        }
    }
    
    // Guardar el área seleccionada y el tipo sensorial dominante en sessionStorage
    sessionStorage.setItem('selectedArea', areaId);
    sessionStorage.setItem('dominantSensoryType', dominantSensoryType);
    
    // Cada área ahora tiene su propia página de experiencia específica
    let experiencePage = 'experiencia.html';
    
    // Redirigir a la página de experiencia específica para cada área
    // Añadir el parámetro de tipo sensorial dominante
    if (areaId === 'aranias') {
        experiencePage = `experiencia-aranias.html?type=${dominantSensoryType}`;
    } else if (areaId === 'feliz') {
        experiencePage = `experiencia-feliz.html?type=${dominantSensoryType}`;
    } else if (areaId === 'triste') {
        experiencePage = `experiencia-triste.html?type=${dominantSensoryType}`;
    }
    
    // Navegar a la página de experiencia
    window.location.href = experiencePage;
}
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1);
            
            // Inicializar offset de ruido
            noiseOffset = random(1000);
            
            // Crear texturas
            createTextures();
            
            // Definir el centro del mundo
            const worldWidth = width * 4;
            const worldHeight = height * 4;
            
            // Definir áreas temáticas con colores
            thematicAreas = [
    { 
        name: "Arañas", 
        id: "aranias",
        center: { x: worldWidth * 0.15, y: worldHeight * 0.15 }, // Moved further to corner
        color: color(255, 100, 100) // Rojo
    },
    { 
        name: "Feliz/Motivación", 
        id: "feliz",
        center: { x: worldWidth * 0.85, y: worldHeight * 0.15 }, // Moved further to corner
        color: color(100, 255, 100) // Verde
    },
    { 
        name: "Triste", 
        id: "triste",
        center: { x: worldWidth * 0.5, y: worldHeight * 0.85 }, // Moved further down
        color: color(100, 100, 255) // Azul
    }
];
            
            // Establecer el centro del mundo como posición inicial
            initialViewX = worldWidth * 0.5;
            initialViewY = worldHeight * 0.5;
            
            // Centrar la vista inicialmente
            targetViewX = initialViewX;
            targetViewY = initialViewY;
            
            // Crear nodos para cada ruta sensorial
            for (let areaIndex = 0; areaIndex < thematicAreas.length; areaIndex++) {
                const area = thematicAreas[areaIndex];
                const mainNodeId = area.id;
                const paths = sensoryPaths[mainNodeId];
                
                // Para cada ruta sensorial de este nodo principal
                for (const path of paths) {
                    // Crear nodos para esta ruta sensorial
                    for (let i = 0; i < NODES_PER_PATH; i++) {
                        // Calcular distancia desde el centro del área (más nodos cerca del centro)
                        // Usar distribución exponencial para concentrar nodos cerca del centro
                        const distanceFactor = pow(random(), 1.5); // Exponencial para concentrar cerca del centro
                        const maxDistance = min(width, height) * 2.0;
                        const distance = distanceFactor * maxDistance;
                        
                        // Posición aleatoria en círculo alrededor del centro del área
                        const angle = random(TWO_PI);
                        const x = area.center.x + cos(angle) * distance;
                        const y = area.center.y + sin(angle) * distance;
                        
                        // Calcular intensidad de color basada en la distancia al centro
                        // Nodos más cercanos al centro tienen color más intenso
                        const colorIntensity = map(distanceFactor, 0, 1, 1, 0.5);
                        
                        // Seleccionar características sensoriales para este nodo
                        const sectionIndex = floor(i / (NODES_PER_PATH / 3));
                        
                        // Seleccionar textura, sonido, palabra y color basados en la ruta
                        const texture = path.textures[min(sectionIndex, path.textures.length - 1)];
                        const nodeSound = path.sounds[min(sectionIndex, path.sounds.length - 1)];
                        const word = path.words[floor(random(path.words.length))];
                        const nodeColor = path.colors[min(sectionIndex, path.colors.length - 1)];
                        
                        // Determinar el tipo de camino (rojo, verde, azul)
                        let pathType = "rojo";
                        if (path.id.includes("verde")) {
                            pathType = "verde";
                        } else if (path.id.includes("azul")) {
                            pathType = "azul";
                        }
                        
                        // Modificar la sección donde se crean los nodos para asignar recursos multimedia fijos
                        // En la función setup(), dentro del bucle que crea nodos para cada ruta sensorial,
                        // modificar la parte donde se crea cada nodo para incluir recursos multimedia:

                        // Buscar la sección donde se crea cada nodo sensorial y reemplazar con:
                        // Crear nodo
                        //const path = paths[paths.findIndex(p => p.id === path.id)];

                        // Modificar la función para seleccionar un recurso aleatorio de un array
                        

                        // Seleccionar recursos multimedia aleatorios para este nodo
                        const nodeImage = getRandomResource(path.images);
                        const nodeVideo = getRandomResource(path.videos);
                        const nodeGif = getRandomResource(path.gifs);
                        const nodeAudio = getRandomResource(path.audios);

                        nodes.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y,
                            vx: 0,
                            vy: 0,
                            radius: random(12, 18), // Tamaño variable
                            color: color(
                                red(color(nodeColor)) * colorIntensity,
                                green(color(nodeColor)) * colorIntensity,
                                blue(color(nodeColor)) * colorIntensity,
                                200
                            ),
                            nodeType: "sensory",
                            pathId: path.id, // ID de la ruta sensorial
                            pathType: pathType, // Tipo de camino (rojo, verde, azul)
                            mainNodeId: mainNodeId, // ID del nodo principal al que pertenece
                            thematicArea: areaIndex, // Índice del área temática
                            name: `${path.name} - Nodo ${i+1}`,
                            noiseOffsetX: random(1000),
                            noiseOffsetY: random(1000),
                            noiseScale: random(0.01, 0.03),
                            screenX: 0,
                            screenY: 0,
                            visible: true,
                            active: true, // Indica si el nodo está activo o no
                            activeTransition: 1.0, // Valor de transición para animación (1.0 = completamente activo)
                            targetActiveTransition: 1.0, // Valor objetivo para la transición
                            labelOpacity: 0,
                            scale: 1.0,
                            targetScale: 1.0,
                            pulseOffset: random(TWO_PI),
                            texture: texture,
                            sound: nodeSound,
                            word: word,
                            rhythm: path.rhythm,
                            pathColor: nodeColor, // Guardar el color original de la ruta
                            distanceFactor: distanceFactor, // Para referencia
                            transitionOffsetX: random(-5, 5), // Offset para movimiento durante transición
                            transitionOffsetY: random(-5, 5),  // Offset para movimiento durante transición
                            // Recursos multimedia asignados a este nodo
                            nodeImage: nodeImage,
                            nodeVideo: nodeVideo,
                            nodeGif: nodeGif,
                            nodeAudio: nodeAudio
                        });
                    }
                }
            }
            
            // Crear nodos neutros (grises)
            for (let i = 0; i < NEUTRAL_NODES; i++) {
                // Distribución en un área 4 veces más grande que la pantalla
                const x = random(0, width * 4);
                const y = random(0, height * 4);
                
                // Color gris con variación
                const grayValue = random(100, 180);
                const nodeColor = color(grayValue, grayValue, grayValue, 180);
                
                // Crear nodo neutro
                nodes.push({
                    x: x,
                    y: y,
                    baseX: x,
                    baseY: y,
                    vx: 0,
                    vy: 0,
                    radius: random(5, 12), // Más pequeños que los temáticos
                    color: nodeColor,
                    nodeType: "neutral",
                    thematicArea: -1, // -1 indica nodo neutro
                    name: `Nodo Neutral ${i+1}`,
                    noiseOffsetX: random(1000),
                    noiseOffsetY: random(1000),
                    noiseScale: random(0.01, 0.02),
                    screenX: 0,
                    screenY: 0,
                    visible: true,
                    active: true, // Indica si el nodo está activo o no
                    activeTransition: 1.0, // Valor de transición para animación
                    targetActiveTransition: 1.0, // Valor objetivo para la transición
                    labelOpacity: 0,
                    scale: 1.0,
                    targetScale: 1.0,
                    pulseOffset: random(TWO_PI),
                    texture: null,
                    sound: null,
                    word: "neutral",
                    rhythm: "neutral",
                    transitionOffsetX: random(-5, 5), // Offset para movimiento durante transición
                    transitionOffsetY: random(-5, 5)  // Offset para movimiento durante transición
                });
            }
            
            // Crear enlaces entre nodos
            createLinks();
            
            // Obtener el elemento para mostrar información del nodo
            nodeInfo = select('#node-info');
            
            // Obtener referencias a los nodos nodriza
            motherNodes = {
                aranias: document.getElementById('mother-node-aranias'),
                feliz: document.getElementById('mother-node-feliz'),
                triste: document.getElementById('mother-node-triste')
            };

            // Obtener referencia al panel de media
mediaPanel = document.getElementById('media-panel');
            
            // Cargar contadores desde sessionStorage
            loadCountersFromStorage();
            
            // Asignar la función openExperience al objeto window para que sea accesible desde HTML
            window.openExperience = openExperience;
        }
        
        // Función para crear texturas
        function createTextures() {
            // Crear imágenes para texturas
            // Arañas - Rojo
            textureImages.muchas_lineas = createTextureImage("muchas_lineas", "#FF0000");
            textureImages.lineas_entrecruzadas = createTextureImage("lineas_entrecruzadas", "#FF3333");
            textureImages.tela_araña = createTextureImage("tela_araña", "#FF6666");
            
            // Arañas - Verde
            textureImages.lineas_que_se_acercan = createTextureImage("lineas_que_se_acercan", "#00FF00");
            textureImages.estructuras_3d = createTextureImage("estructuras_3d", "#33FF33");
            textureImages.entramados = createTextureImage("entramados", "#66FF66");
            
            // Arañas - Azul
            textureImages.menos_lineas = createTextureImage("menos_lineas", "#0000FF");
            textureImages.rotas = createTextureImage("rotas", "#3333FF");
            textureImages.endebles = createTextureImage("endebles", "#6666FF");
            
            // Feliz - Rojo
            textureImages.granulado = createTextureImage("granulado", "#FF9999");
            textureImages.vibrante = createTextureImage("vibrante", "#FF6666");
            textureImages.texturado = createTextureImage("texturado", "#FF3333");
            
            // Feliz - Verde
            textureImages.mojado = createTextureImage("mojado", "#99FF99");
            textureImages.brillante = createTextureImage("brillante", "#66FF66");
            textureImages.fluido = createTextureImage("fluido", "#33FF33");
            
            // Feliz - Azul
            textureImages.amarillo = createTextureImage("amarillo", "#FFFF00");
            textureImages.dorado = createTextureImage("dorado", "#FFD700");
            textureImages.luminoso = createTextureImage("luminoso", "#FFFFCC");
            
            // Triste - Rojo
            textureImages.liso_y_frio = createTextureImage("liso_frio", "#CC9999");
            textureImages.plano = createTextureImage("plano", "#BB7777");
            textureImages.simple = createTextureImage("simple", "#AA5555");
            
            // Triste - Verde
            textureImages.humeda = createTextureImage("humeda", "#99CC99");
            textureImages.fría = createTextureImage("fria", "#77BB77");
            textureImages.brumosa = createTextureImage("brumosa", "#55AA55");
            
            // Triste - Azul
            textureImages.pegajosa = createTextureImage("pegajosa", "#9999CC");
            textureImages.viscosa = createTextureImage("viscosa", "#7777BB");
            textureImages.densa = createTextureImage("densa", "#5555AA");
        }
        
        // Función auxiliar para crear imágenes de textura
        function createTextureImage(name, baseColor) {
            // En una implementación real, cargarías imágenes reales
            // Esta es una función placeholder que crea una imagen con un patrón básico
            const img = createGraphics(100, 100);
            img.background(baseColor);
            
            // Dibujar un patrón básico basado en el nombre
            img.stroke(255, 100);
            img.strokeWeight(2);
            
            if (name.includes("lineas")) {
                // Dibujar varias líneas
                const numLines = name.includes("muchas") ? 20 : (name.includes("menos") ? 5 : 10);
                for (let i = 0; i < numLines; i++) {
                    img.line(
                        random(100), random(100),
                        random(100), random(100)
                    );
                }
            } else if (name.includes("entrecruzadas") || name.includes("tela") || name.includes("entramados")) {
                // Dibujar líneas entrecruzadas
                for (let i = 0; i < 10; i++) {
                    img.line(0, i * 10, 100, 100 - i * 10);
                    img.line(i * 10, 0, 100 - i * 10, 100);
                }
            } else if (name.includes("3d") || name.includes("estructuras")) {
                // Dibujar formas que sugieran 3D
                img.push();
                img.noFill();
                for (let i = 0; i < 5; i++) {
                    img.rect(20 + i * 5, 20 + i * 5, 60 - i * 10, 60 - i * 10);
                }
                img.pop();
            } else if (name.includes("granulado") || name.includes("texturado")) {
                // Dibujar puntos para textura granulada
                img.stroke(255, 150);
                img.strokeWeight(1);
                for (let i = 0; i < 200; i++) {
                    img.point(random(100), random(100));
                }
            } else if (name.includes("liso") || name.includes("plano") || name.includes("simple")) {
                // Superficies más limpias con pocas líneas
                img.stroke(255, 50);
                img.line(0, 25, 100, 25);
                img.line(0, 50, 100, 50);
                img.line(0, 75, 100, 75);
            } else if (name.includes("mojado") || name.includes("fluido") || name.includes("humeda")) {
                // Textura que sugiere humedad
                img.noStroke();
                img.fill(255, 100);
                for (let i = 0; i < 20; i++) {
                    const size = random(5, 15);
                    img.ellipse(random(100), random(100), size, size);
                }
            } else {
                // Textura genérica para otros casos
                img.stroke(255, 120);
                for (let i = 0; i < 8; i++) {
                    img.line(0, i * 12, 100, i * 12);
                    img.line(i * 12, 0, i * 12, 100);
                }
            }
            
            return img;
        }
        
        function createLinks() {
            // Crear enlaces entre nodos de la misma ruta sensorial
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "sensory") {
                    const pathId = nodes[i].pathId;
                    
                    // Buscar otros nodos de la misma ruta sensorial
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "sensory" && nodes[j].pathId === pathId) {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con cierta probabilidad
                            const maxDist = min(width, height) * 0.8;
                            if (dist < maxDist && random() < (1 - dist/maxDist) * 0.4) {
                                // Crear enlace con el color de la ruta
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: pathId,
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 4))
                                    ),
                                    velocities: Array(floor(random(1, 4))).fill().map(() => ({
                                        x: random(-0.1, 0.1),
                                        y: random(-0.1, 0.1)
                                    })),
                                    color: nodes[i].color,
                                    opacity: random(0.5, 0.8),
                                    pulseRate: random(0.001, 0.005),
                                    pulseAmount: random(0.1, 0.3)
                                });
                            }
                        }
                    }
                }
            }
            
            // Crear algunos enlaces entre nodos neutros
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "neutral") {
                    // Buscar otros nodos neutros cercanos
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "neutral") {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con baja probabilidad
                            const maxDist = min(width, height) * 0.5;
                            if (dist < maxDist && random() < 0.08) {
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: "neutral",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 2))
                                    ),
                                    velocities: Array(floor(random(1, 2))).fill().map(() => ({
                                        x: random(-0.05, 0.05),
                                        y: random(-0.05, 0.05)
                                    })),
                                    color: color(150, 150, 150, 100),
                                    opacity: random(0.2, 0.4),
                                    pulseRate: random(0.001, 0.002),
                                    pulseAmount: random(0.05, 0.1)
                                });
                            }
                        }
                    }
                }
            }
            
            // Crear algunos enlaces entre nodos temáticos y neutros
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "sensory") {
                    // Buscar nodos neutros cercanos
                    for (let j = 0; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "neutral") {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con baja probabilidad
                            const maxDist = min(width, height) * 0.6;
                            if (dist < maxDist && random() < 0.03) {
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: "transition",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(1, 3))
                                    ),
                                    velocities: Array(floor(random(1, 3))).fill().map(() => ({
                                        x: random(-0.08, 0.08),
                                        y: random(-0.08, 0.08)
                                    })),
                                    // Color mezclado entre temático y neutro
                                    color: lerpColor(
                                        nodes[i].color, 
                                        color(150, 150, 150), 
                                        0.5
                                    ),
                                    opacity: random(0.3, 0.6),
                                    pulseRate: random(0.001, 0.004),
                                    pulseAmount: random(0.1, 0.25)
                                });
                            }
                        }
                    }
                }
            }
            
            // Crear algunos enlaces adicionales entre áreas temáticas diferentes
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeType === "sensory") {
                    // Buscar nodos de otras áreas temáticas
                    for (let j = 0; j < nodes.length; j++) {
                        if (nodes[j].nodeType === "sensory" && nodes[j].thematicArea !== nodes[i].thematicArea) {
                            // Calcular distancia entre nodos
                            const dist = distance2D(
                                nodes[i].x, nodes[i].y,
                                nodes[j].x, nodes[j].y
                            );
                            
                            // Conectar solo nodos cercanos con muy baja probabilidad
                            const maxDist = min(width, height) * 0.7;
                            if (dist < maxDist && random() < 0.01) {
                                // Color mezclado entre las dos áreas temáticas
                                const mixedColor = lerpColor(
                                    nodes[i].color, 
                                    nodes[j].color, 
                                    0.5
                                );
                                
                                links.push({
                                    source: i,
                                    target: j,
                                    pathId: "cross_area",
                                    points: generateIntermediatePoints2D(
                                        nodes[i].x, nodes[i].y,
                                        nodes[j].x, nodes[j].y,
                                        floor(random(2, 4))
                                    ),
                                    velocities: Array(floor(random(2, 4))).fill().map(() => ({
                                        x: random(-0.1, 0.1),
                                        y: random(-0.1, 0.1)
                                    })),
                                    color: mixedColor,
                                    opacity: random(0.4, 0.7),
                                    pulseRate: random(0.002, 0.005),
                                    pulseAmount: random(0.15, 0.3)
                                });
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            background(0);
            
            // Incrementar tiempo global
            globalTime += 0.01;
            
            // Actualizar posición de la vista con suavizado
            viewX = lerp(viewX, targetViewX, 0.05);
            viewY = lerp(viewY, targetViewY, 0.05);
            
            // Aplicar transformación para la vista
            translate(width/2 - viewX, height/2 - viewY);
            
            // Actualizar posiciones en pantalla de los nodos
            updateScreenPositions();
            
            // Verificar si el mouse está sobre algún nodo
            checkMouseOverNodes();
            
            // Dibujar enlaces
            drawLinks();
            
            // Dibujar nodos
            drawNodes();
            
            // Actualizar posiciones de los nodos con movimiento orgánico
            updateNodePositions();
            
            // Si hay una ruta seleccionada, reforzar su presencia
            if (selectedPath) {
                emphasizeSelectedPath();
            }
            
            // Información en pantalla (fuera de la transformación)
            resetMatrix();
            updateNodeInfo();
        }
        
        // Función para mostrar más nodos del tipo seleccionado y ocultar otros
        function updateNodeVisibility(selectedPathType) {
    if (!currentArea) return;
    
    // Contar cuántos nodos activos hay del tipo seleccionado
    let activeNodesCount = 0;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node.nodeType === "sensory" && node.mainNodeId === currentArea && 
            node.pathType === selectedPathType && node.activeTransition > 0.5) {
            activeNodesCount++;
        }
    }
    
    // Establecer un límite máximo de nodos por tipo sensorial
    const MAX_NODES_PER_TYPE = 60;
    
    // Para cada nodo en el sistema
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        
        if (node.nodeType === "sensory") {
            if (node.mainNodeId === currentArea) {
                // Si el nodo pertenece al área seleccionada
                if (node.pathType === selectedPathType) {
                    // Mostrar nodos del tipo de camino seleccionado (sin cambiar tamaño)
                    node.targetActiveTransition = 1.0;
                    node.targetScale = 1.0; // Mantener tamaño normal
                    
                    // Generar nuevos nodos SOLO si no hemos alcanzado el límite
                    if (activeNodesCount < MAX_NODES_PER_TYPE && random() < 0.05) {
                        generateNewNode(currentArea, selectedPathType, node);
                        activeNodesCount++;
                    }
                } else {
                    // Hacer desaparecer nodos de otros tipos de camino en la misma área
                    // Con una probabilidad para que sea gradual
                    if (random() < 0.2) {
                        node.targetActiveTransition = 0.0; // Desaparecer completamente
                    } else {
                        node.targetActiveTransition = Math.max(0, node.activeTransition - 0.1); // Ir desapareciendo gradualmente
                    }
                }
            } else {
                // Los nodos de otras áreas permanecen visibles pero atenuados
                // No afectar a otros ejes temáticos
                node.targetActiveTransition = 0.3;
                node.targetScale = 1.0; // Mantener tamaño normal
            }
        } else if (node.nodeType === "neutral") {
            // Los nodos neutros siempre permanecen visibles
            node.targetActiveTransition = 0.7;
            node.targetScale = 1.0; // Mantener tamaño normal
        }
    }
}
        
        function emphasizeSelectedPath() {
    // Hacer más visibles los nodos de la ruta seleccionada
    // y menos visibles los demás, pero sin cambiar tamaño
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node.nodeType === "sensory") {
            if (node.pathId === selectedPath) {
                // Mantener tamaño normal pero reforzar color
                node.targetScale = 1.0;
                // Reforzar color original
                node.color = color(
                    red(node.pathColor),
                    green(node.pathColor),
                    blue(node.pathColor),
                    230
                );
            } else {
                // Mantener tamaño normal pero atenuar color
                node.targetScale = 1.0;
                // Atenuar color
                node.color = color(
                    red(node.pathColor) * 0.7,
                    green(node.pathColor) * 0.7,
                    blue(node.pathColor) * 0.7,
                    100
                );
            }
        } else if (node.nodeType === "neutral") {
            // Nodos neutros mantienen tamaño normal
            node.targetScale = 1.0;
            node.color = color(100, 100, 100, 80);
        }
    }
    
    // Ajustar visibilidad de enlaces
    for (let link of links) {
        if (link.pathId === selectedPath) {
            link.opacity = random(0.7, 0.9); // Más visibles
            link.pulseAmount = random(0.2, 0.4); // Más pulsación
        } else if (link.pathId !== "neutral") {
            link.opacity = random(0.1, 0.3); // Menos visibles
            link.pulseAmount = random(0.05, 0.1); // Menos pulsación
        } else {
            link.opacity = random(0.05, 0.15); // Casi invisibles
        }
    }
}
        
        function drawLinks() {
            for (const link of links) {
                const source = nodes[link.source];
                const target = nodes[link.target];
                
                // Solo dibujar si ambos nodos son visibles y tienen alguna opacidad
                if (source.visible && target.visible && 
                    source.activeTransition > 0.1 && target.activeTransition > 0.1) {
                    
                    // Calcular opacidad con efecto de pulso y considerando la transición de los nodos
                    const pulseEffect = sin(globalTime * link.pulseRate * TWO_PI) * link.pulseAmount + 1;
                    const transitionFactor = min(source.activeTransition, target.activeTransition);
                    const currentOpacity = link.opacity * pulseEffect * transitionFactor;
                    
                    // Establecer color y opacidad
                    stroke(
                        red(link.color), 
                        green(link.color), 
                        blue(link.color), 
                        alpha(link.color) * currentOpacity
                    );
                    strokeWeight(1);
                    
                    // Dibujar línea orgánica
                    drawOrganicLine2D(
                        source.x, source.y,
                        target.x, target.y,
                        link.points
                    );
                    
                    // Actualizar posiciones de los puntos intermedios
                    updateLinkPoints(link);
                }
            }
        }
        
        function drawNodes() {
            noStroke();
            
            // Primero dibujar los nodos que no están en hover o seleccionados
            for (let i = 0; i < nodes.length; i++) {
                if (i !== hoveredNode && i !== selectedNode) {
                    drawNode(i);
                }
            }
            
            // Luego dibujar el nodo seleccionado y el nodo en hover para que aparezcan encima
            if (selectedNode !== null) {
                drawNode(selectedNode);
            }
            
            if (hoveredNode !== null && hoveredNode !== selectedNode) {
                drawNode(hoveredNode);
            }
        }
        
        function drawNode(i) {
            const node = nodes[i];
            
            // Actualizar la transición de activación con suavizado
            node.activeTransition = lerp(node.activeTransition, node.targetActiveTransition, 0.05);
            
            // Solo dibujar si el nodo es visible y tiene alguna opacidad
            if (node.visible && node.activeTransition > 0.01) {
                // Actualizar escala con suavizado
                node.scale = lerp(node.scale, node.targetScale, 0.2);
                
                // Efecto de pulso basado en el ritmo del nodo
                let pulseEffect = 1.0;
                
                if (node.rhythm === "pulso_constante") {
                    // Pulso regular y constante
                    pulseEffect = sin(globalTime * 2 + node.pulseOffset) * 0.15 + 1;
                } else if (node.rhythm === "iiiiiiiiiiiiiiiiiiiiiip") {
                    // Pulso irregular entrecortado
                    pulseEffect = noise(globalTime + node.pulseOffset) * 0.3 + 0.85;
                } else if (node.rhythm === "oscilacion_lenta") {
                    // Oscilación suave y lenta
                    pulseEffect = sin(globalTime * 0.5 + node.pulseOffset) * 0.1 + 1;
                } else if (node.rhythm === "desvanece") {
                    // Desvanecimiento y reaparición
                    pulseEffect = abs(sin(globalTime * 0.3 + node.pulseOffset)) * 0.5 + 0.7;
                } else if (node.rhythm === "constante") {
                    // Sin apenas variación
                    pulseEffect = 1.0 + sin(globalTime * 0.1 + node.pulseOffset) * 0.05;
                } else {
                    // Nodos sin ritmo específico
                    pulseEffect = sin(globalTime * 0.5 + node.pulseOffset) * 0.05 + 1;
                }
                
                // Aplicar escala considerando la transición de activación
                const currentScale = node.scale * pulseEffect * node.activeTransition;
                
                // Calcular posición con offset de transición
                const transitionX = node.x + node.transitionOffsetX * (1 - node.activeTransition);
                const transitionY = node.y + node.transitionOffsetY * (1 - node.activeTransition);
                
                // Efecto de círculos concéntricos para TODOS los nodos
                // Efecto de bloom (varias capas con diferentes tamaños y opacidades)
                for (let j = 3; j > 0; j--) {
                    // Nodo seleccionado o hover: más brillante
                    if (selectedNode === i || hoveredNode === i) {
                        fill(
                            min(red(node.color) + 70, 255),
                            min(green(node.color) + 70, 255),
                            min(blue(node.color) + 70, 255),
                            60 / j * node.activeTransition // Opacidad afectada por la transición
                        );
                    } else {
                        fill(
                            red(node.color), 
                            green(node.color), 
                            blue(node.color), 
                            50 / j * node.activeTransition
                        );
                    }
                    circle(transitionX, transitionY, node.radius * 2 * j * currentScale);
                }
                
                // Si el nodo tiene textura, usarla como patrón en el círculo central
                if (node.texture && textureImages[node.texture]) {
                    // Dibujar imagen de textura como fondo del nodo central
                    const textureImg = textureImages[node.texture];
                    push();
                    imageMode(CENTER);
                    
                    // Ajustar tamaño de la textura al nodo
                    const texSize = node.radius * 2 * currentScale;
                    
                    // Ajustar opacidad de la imagen
                    tint(255, 255 * node.activeTransition);
                    image(textureImg, transitionX, transitionY, texSize, texSize);
                    noTint();
                    pop();
                } else {
                    // Nodo principal
                    if (selectedNode === i || hoveredNode === i) {
                        fill(
                            min(red(node.color) + 70, 255),
                            min(green(node.color) + 70, 255),
                            min(blue(node.color) + 70, 255),
                            230 * node.activeTransition
                        );
                    } else {
                        fill(
                            red(node.color), 
                            green(node.color), 
                            blue(node.color), 
                            200 * node.activeTransition
                        );
                    }
                    circle(transitionX, transitionY, node.radius * 2 * currentScale);
                }
                
                // Si el nodo tiene una palabra, mostrarla cuando está seleccionado o en hover
                if (node.word && (selectedNode === i || hoveredNode === i)) {
                    fill(255, 255, 255, 230 * node.activeTransition);
                    textAlign(CENTER, CENTER);
                    textSize(12);
                    // Dibujar palabra encima del nodo
                    text(node.word, transitionX, transitionY - node.radius * currentScale - 10);
                }
            }
        }
        
        function updateNodePositions() {
    for (let node of nodes) {
        // Calcular nuevas velocidades basadas en ruido Perlin
        const time = frameCount * 0.01;
        const noiseX = noise(node.noiseOffsetX + time) * 2 - 1;
        const noiseY = noise(node.noiseOffsetY + time) * 2 - 1;
        
        // Aplicar suavizado a los cambios de velocidad
        node.vx = lerp(node.vx, noiseX * node.noiseScale * 2, 0.02);
        node.vy = lerp(node.vy, noiseY * node.noiseScale * 2, 0.02);
        
        // Actualizar posición solo si el nodo está completamente activo
        // Esto evita que los nodos que están desapareciendo sigan moviéndose
        if (node.activeTransition > 0.9) {
            node.x += node.vx;
            node.y += node.vy;
            
            // Mantener cerca de la posición base con fuerza suave
            node.x += (node.baseX - node.x) * 0.01;
            node.y += (node.baseY - node.y) * 0.01;
        }
        
        // Actualizar escala objetivo basada en hover
        if (hoveredNode === nodes.indexOf(node)) {
            node.targetScale = 1.1; // Agrandar ligeramente al hacer hover
        } else if (selectedNode !== nodes.indexOf(node) && !selectedPath) {
            // Solo restablecer si no hay una ruta seleccionada
            node.targetScale = 1.0; // Tamaño normal
        }
    }
}
        
        // Función para actualizar las posiciones de los puntos intermedios de los enlaces
        function updateLinkPoints(link) {
            if (!link.points || !link.velocities || link.points.length !== link.velocities.length) {
                return; // Evitar errores si los arrays no coinciden
            }
            
            for (let i = 0; i < link.points.length; i++) {
                const point = link.points[i];
                const velocity = link.velocities[i];
                
                // Actualizar posición con velocidad
                point.x += velocity.x;
                point.y += velocity.y;
                
                // Calcular posición base (punto en la línea recta entre origen y destino)
                const t = (i + 1) / (link.points.length + 1);
                const sourceX = nodes[link.source].x;
                const sourceY = nodes[link.source].y;
                const targetX = nodes[link.target].x;
                const targetY = nodes[link.target].y;
                
                const baseX = sourceX + (targetX - sourceX) * t;
                const baseY = sourceY + (targetY - sourceY) * t;
                
                // Mantener el punto cerca de su posición base
                point.x += (baseX - point.x) * 0.02;
                point.y += (baseY - point.y) * 0.02;
            }
        }
        
        // Función para actualizar las posiciones en pantalla de los nodos
        function updateScreenPositions() {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                
                // Calcular posición en pantalla
                node.screenX = node.x - viewX + width/2;
                node.screenY = node.y - viewY + height/2;
                
                // Verificar si está dentro de la pantalla (con margen)
                const margin = node.radius * 3;
                node.visible = 
                    node.screenX + margin >= 0 && 
                    node.screenX - margin <= width && 
                    node.screenY + margin >= 0 && 
                    node.screenY - margin <= height;
            }
        }
        
        // Función para verificar si el mouse está sobre algún nodo
        function checkMouseOverNodes() {
    // Resetear hover
    const previousHoveredNode = hoveredNode;
    hoveredNode = null;
    
    // Verificar todos los nodos
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        
        // Solo verificar nodos visibles y con suficiente opacidad
        if (node.visible && node.activeTransition > 0.5) {
            const distance = dist(mouseX, mouseY, node.screenX, node.screenY);
            
            if (distance < node.radius * node.scale) {
                hoveredNode = i;
                
                // Modificar la función showNodeMedia para usar los recursos específicos de cada nodo
                // Reemplazar la función showNodeMedia con esta versión actualizada:

                // Función para mostrar media del nodo
function showNodeMedia(node) {
    if (node.nodeType !== "sensory") return;
    
    // Variables para almacenar el contenido multimedia
    let mediaHTML = '';
    let caption = '';
    let hasMedia = false;
    
    // Determinar qué tipo de media mostrar (prioridad: video > gif > imagen)
    if (node.nodeVideo) {
        mediaHTML = `<video autoplay loop muted><source src="${node.nodeVideo.url}" type="video/mp4"></video>`;
        caption = node.nodeVideo.caption;
        hasMedia = true;
    } 
    else if (node.nodeGif) {
        mediaHTML = `<img src="${node.nodeGif.url}" alt="${node.nodeGif.caption}">`;
        caption = node.nodeGif.caption;
        hasMedia = true;
    } 
    else if (node.nodeImage) {
        mediaHTML = `<img src="${node.nodeImage.url}" alt="${node.nodeImage.caption}">`;
        caption = node.nodeImage.caption;
        hasMedia = true;
    }
    
    // Reproducir audio si está disponible
    if (node.nodeAudio && !audioPlaying) {
        playAudio(node.nodeAudio.url);
    }
    
    // Mostrar el panel de media si hay contenido
    if (hasMedia) {
        const mediaContent = document.getElementById('media-content');
        const mediaCaption = document.getElementById('media-caption');
        
        mediaContent.innerHTML = mediaHTML;
        mediaCaption.textContent = caption;
        
        // Posicionar el panel encima del nodo
        const panel = document.getElementById('media-panel');
        panel.style.left = (node.screenX - 150) + 'px'; // Centrado horizontalmente
        panel.style.top = (node.screenY - 320) + 'px'; // Encima del nodo
        panel.style.display = 'block';
        panel.style.opacity = '1';
    } else {
        // Si no hay media, mostrar al menos la palabra del nodo en el panel
        if (node.word) {
            const mediaContent = document.getElementById('media-content');
            const mediaCaption = document.getElementById('media-caption');
            
            mediaContent.innerHTML = `<div style="height: 100px; display: flex; align-items: center; justify-content: center; font-size: 24px; color: white;">${node.word}</div>`;
            mediaCaption.textContent = `${node.name}`;
            
            const panel = document.getElementById('media-panel');
            panel.style.left = (node.screenX - 150) + 'px';
            panel.style.top = (node.screenY - 320) + 'px';
            panel.style.display = 'block';
            panel.style.opacity = '1';
        } else {
            hideMediaPanel();
        }
    }
}
                
                break; // Tomar solo el primer nodo encontrado
            }
        }
    }
    
    // Si ya no hay nodo en hover, ocultar el panel de media
    if (hoveredNode === null && previousHoveredNode !== null) {
        hideMediaPanel();
        stopAudio();
    }
}
        
        // Función para ocultar el panel de media
function hideMediaPanel() {
    const panel = document.getElementById('media-panel');
    panel.style.opacity = '0';
    setTimeout(() => {
        if (panel.style.opacity === '0') {
            panel.style.display = 'none';
        }
    }, 300);
}

// Modificar las funciones de audio para incluir fade in/fade out
// Reemplazar las funciones de audio con estas versiones actualizadas:

// Función para reproducir audio con fade in
function playAudio(url) {
    stopAudio(); // Detener audio anterior si existe
    
    currentAudio = new Audio(url);
    currentAudio.volume = 0; // Comenzar con volumen 0
    
    // Manejar errores de carga
    currentAudio.onerror = function() {
        console.error("Error al cargar el audio:", url);
        audioPlaying = false;
        currentAudio = null;
    };
    
    // Reproducir el audio
    currentAudio.play().then(() => {
        audioPlaying = true;
        
        // Fade in
        let volume = 0;
        const fadeInInterval = setInterval(() => {
            volume += 0.05;
            if (volume >= 0.5) {
                volume = 0.5;
                clearInterval(fadeInInterval);
            }
            if (currentAudio) {
                currentAudio.volume = volume;
            } else {
                clearInterval(fadeInInterval);
            }
        }, 50);
    }).catch(error => {
        console.error("Error al reproducir audio:", error);
        audioPlaying = false;
        currentAudio = null;
    });
    
    // Establecer evento para cuando termine el audio
    currentAudio.onended = function() {
        audioPlaying = false;
        currentAudio = null;
    };
}

// Función para detener audio con fade out
function stopAudio() {
    if (currentAudio && audioPlaying) {
        // Fade out
        const fadeOutInterval = setInterval(() => {
            if (currentAudio.volume > 0.05) {
                currentAudio.volume -= 0.05;
            } else {
                clearInterval(fadeOutInterval);
                currentAudio.pause();
                currentAudio.currentTime = 0;
                audioPlaying = false;
                currentAudio = null;
            }
        }, 50);
    } else if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        audioPlaying = false;
        currentAudio = null;
    }
}

// Funciones para generar sonidos con p5.sound (comentadas por ahora)
/*
function setupP5Sound() {
    // Inicializar objetos de sonido
    oscillator = new p5.Oscillator('sine');
    reverb = new p5.Reverb();
    delay = new p5.Delay();
    
    // Configurar efectos
    reverb.process(oscillator, 3, 2);
    delay.process(oscillator, 0.12, 0.7, 2300);
}

function playOscillator(frequency, duration) {
    oscillator.freq(frequency);
    oscillator.amp(0.5);
    oscillator.start();
    
    // Detener después de la duración especificada
    setTimeout(() => {
        oscillator.amp(0, 0.5); // Fade out
        setTimeout(() => {
            oscillator.stop();
        }, 500);
    }, duration);
}
*/
        
        // Función para actualizar la información del nodo
        function updateNodeInfo() {
            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                let infoText = `${node.name}`;
                
                if (node.nodeType === "sensory") {
                    infoText += ` - Haz clic para seguir la ruta ${node.pathId}`;
                    if (node.texture) infoText += ` | Textura: ${node.texture}`;
                    if (node.sound) infoText += ` | Sonido: ${node.sound}`;
                    if (node.word) infoText += ` | Palabra: ${node.word}`;
                } else {
                    infoText += " - Haz clic para volver al centro";
                }
                
                nodeInfo.html(infoText);
            } else {
                nodeInfo.html("Mueve el cursor sobre un nodo para ver información");
            }
        }
        
        // Función para generar puntos intermedios para líneas orgánicas en 2D
        function generateIntermediatePoints2D(x1, y1, x2, y2, numPoints) {
            const points = [];
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                
                // Línea base
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                // Vector dirección
                const dirX = x2 - x1;
                const dirY = x2 - y1;
                
                // Vector perpendicular
                const perpX = -dirY;
                const perpY = dirX;
                
                // Normalizar
                const perpLength = sqrt(perpX * perpX + perpY * perpY);
                let normPerpX = 0;
                let normPerpY = 0;
                
                if (perpLength > 0) {
                    normPerpX = perpX / perpLength;
                    normPerpY = perpY / perpLength;
                }
                
                // Aplicar desviación
                const deviation = random(-30, 30);
                
                points.push({
                    x: baseX + normPerpX * deviation,
                    y: baseY + normPerpY * deviation
                });
            }
            
            return points;
        }
        
        // Función para dibujar línea orgánica/quebrada en 2D
        function drawOrganicLine2D(x1, y1, x2, y2, points) {
            noFill();
            beginShape();
            vertex(x1, y1);
            
            for (const point of points) {
                vertex(point.x, point.y);
            }
            
            vertex(x2, y2);
            endShape();
        }
        
        // Función auxiliar para calcular distancia en 2D
        function distance2D(x1, y1, x2, y2) {
            return sqrt(
                (x2 - x1) * (x2 - x1) + 
                (y2 - y1) * (y2 - y1)
            );
        }
        
        // Función para navegar hacia un área temática
        function navigateToThematicArea(areaIndex) {
    const area = thematicAreas[areaIndex];
    
    // Calcular vector desde la posición actual hacia el área
    const dirX = area.center.x - targetViewX;
    const dirY = area.center.y - targetViewY;
    
    // Calcular distancia
    const distance = sqrt(dirX * dirX + dirY * dirY);
    
    if (distance > 0) {
        // Mover un porcentaje hacia el área (movimiento gradual)
        // Aumentado el movePercentage para un desplazamiento mayor
        const movePercentage = map(distance, 0, width * 2, 0.3, 0.6); // Aumentado para acercarse más
        const moveDistance = distance * movePercentage;
        
        // Normalizar el vector
        const normX = dirX / distance;
        const normY = dirY / distance;
        
        // Actualizar posición objetivo
        targetViewX += normX * moveDistance;
        targetViewY += normY * moveDistance;
        
        // Acercarse más al centro del área temática basado en el contador
        // Cuantos más clicks, más cerca del centro
        if (currentArea) {
            const zoomFactor = map(pathCounts[currentArea].count, 0, pathCounts[currentArea].maxCount, 0, 0.2);
            targetViewX = lerp(targetViewX, area.center.x, zoomFactor);
            targetViewY = lerp(targetViewY, area.center.y, zoomFactor);
        }
    }
}
        
        // Función para navegar hacia el centro
        function navigateToCenter() {
            // Calcular vector desde la posición actual hacia el centro
            const dirX = initialViewX - targetViewX;
            const dirY = initialViewY - targetViewY;
            
            // Calcular distancia
            const distance = sqrt(dirX * dirX + dirY * dirY);
            
            if (distance > 0) {
                // Mover un porcentaje hacia el centro (movimiento gradual)
                const movePercentage = map(distance, 0, width * 2, 0.1, 0.3);
                const moveDistance = distance * movePercentage;
                
                // Normalizar el vector
                const normX = dirX / distance;
                const normY = dirY / distance;
                
                // Actualizar posición objetivo
                targetViewX += normX * moveDistance;
                targetViewY += normY * moveDistance;
            }
        }
        
        // Función para reiniciar todos los nodos a su estado activo
        function resetAllNodes() {
    for (let node of nodes) {
        node.targetActiveTransition = 1.0;
        node.targetScale = 1.0; // Tamaño normal para todos
        
        if (node.nodeType === "sensory") {
            node.color = color(
                red(node.pathColor),
                green(node.pathColor),
                blue(node.pathColor),
                200
            );
        }
    }
}
        
        // Update the mousePressed function
        function mousePressed() {
    if (hoveredNode !== null) {
        const node = nodes[hoveredNode];
        
        // Si es un nodo sensorial, seleccionar su ruta y navegar a su área
        if (node.nodeType === "sensory") {
            selectedPath = node.pathId;
            selectedNode = hoveredNode;
            
            // Actualizar el área temática actual
            currentArea = node.mainNodeId;
            
            // Incrementar el contador para esta área de forma más moderada
            // Solo incrementar si no hemos alcanzado el máximo
            if (pathCounts[currentArea].count < pathCounts[currentArea].maxCount) {
                pathCounts[currentArea].count += 0.5;
                
                // Incrementar el contador específico para este tipo sensorial
                pathCounts[currentArea][node.pathType] += 0.5;
                
                // Guardar contadores en sessionStorage
                saveCountersToStorage();
                
                // Actualizar visualización de contadores
                updateCounterDisplay();
            }
            
            // Actualizar visibilidad de nodos basada en el tipo de camino seleccionado
            updateNodeVisibility(node.pathType);
            
            // Navegar hacia el área temática y acercarse más al centro
            navigateToThematicArea(node.thematicArea);
        } 
        // Si es un nodo neutro, volver al centro y neutralizar progreso
        else if (node.nodeType === "neutral") {
            selectedPath = null;
            selectedNode = null;
            
            // Disminuir el contador para el área actual (regresión)
            if (currentArea) {
                // Reducir el contador general de forma más moderada
                pathCounts[currentArea].count = Math.max(0, pathCounts[currentArea].count - 0.5);
                
                // Reducir todos los contadores sensoriales proporcionalmente
                pathCounts[currentArea].rojo = Math.max(0, pathCounts[currentArea].rojo - 0.25);
                pathCounts[currentArea].verde = Math.max(0, pathCounts[currentArea].verde - 0.25);
                pathCounts[currentArea].azul = Math.max(0, pathCounts[currentArea].azul - 0.25);
                
                // Guardar contadores en sessionStorage
                saveCountersToStorage();
                
                // Actualizar visualización de contadores
                updateCounterDisplay();
                
                // Ocultar el nodo nodriza cuando se hace clic en un nodo neutro
                hideAllMotherNodes();
            }
            
            // Si el contador llega a cero, reiniciar el área actual
            if (currentArea && pathCounts[currentArea].count === 0) {
                currentArea = null;
            }
            
            // Restablecer todos los nodos a su estado activo
            resetAllNodes();
            
            // Volver al centro
            navigateToCenter();
        }
        return false; // Prevenir comportamiento predeterminado
    }
}

// Modificar la función generateNewNode para asignar recursos multimedia fijos a los nuevos nodos
// Reemplazar la función generateNewNode with this versión actualizada:

// 4. Agregar función para generar nuevos nodos
function generateNewNode(areaId, pathType, sourceNode) {
    // Encontrar la información del área
    const area = thematicAreas.find(a => a.id === areaId);
    if (!area) return;
    
    // Encontrar la información del camino
    const paths = sensoryPaths[areaId];
    const path = paths[paths.findIndex(p => p.id === path.id)];
    if (!path) return;
    
    // Generar una posición cerca del nodo fuente
    const angle = random(TWO_PI);
    const distance = random(50, 150);
    const x = sourceNode.x + cos(angle) * distance;
    const y = sourceNode.y + sin(angle) * distance;
    
    // Calcular intensidad de color
    const distanceFactor = 0.7; // Intensidad media
    
    // Seleccionar características aleatorias del camino
    const sectionIndex = floor(random(3));
    const texture = path.textures[min(sectionIndex, path.textures.length - 1)];
    const nodeSound = path.sounds[min(sectionIndex, path.sounds.length - 1)];
    const word = path.words[floor(random(path.words.length))];
    const nodeColor = path.colors[min(sectionIndex, path.colors.length - 1)];
    
    // Seleccionar recursos multimedia aleatorios para este nodo
    const nodeImage = getRandomResource(path.images);
    const nodeVideo = getRandomResource(path.videos);
    const nodeGif = getRandomResource(path.gifs);
    const nodeAudio = getRandomResource(path.audios);
    
    // Crear el nuevo nodo
    const newNode = {
        x: x,
        y: y,
        baseX: x,
        baseY: y,
        vx: 0,
        vy: 0,
        radius: random(12, 18),
        color: color(
            red(color(nodeColor)) * distanceFactor,
            green(color(nodeColor)) * distanceFactor,
            blue(color(nodeColor)) * distanceFactor,
            200
        ),
        nodeType: "sensory",
        pathId: path.id,
        pathType: pathType,
        mainNodeId: areaId,
        thematicArea: thematicAreas.findIndex(a => a.id === areaId),
        name: `${path.name} - Nodo Nuevo`,
        noiseOffsetX: random(1000),
        noiseOffsetY: random(1000),
        noiseScale: random(0.01, 0.03),
        screenX: 0,
        screenY: 0,
        visible: true,
        active: true,
        activeTransition: 0.0, // Comenzar invisible y aparecer gradualmente
        targetActiveTransition: 1.0,
        labelOpacity: 0,
        scale: 0.1, // Comenzar pequeño
        targetScale: 1.0, // Crecer a tamaño normal
        pulseOffset: random(TWO_PI),
        texture: texture,
        sound: nodeSound,
        word: word,
        rhythm: path.rhythm,
        pathColor: nodeColor,
        distanceFactor: distanceFactor,
        transitionOffsetX: random(-5, 5),
        transitionOffsetY: random(-5, 5),
        // Recursos multimedia asignados a este nodo
        nodeImage: nodeImage,
        nodeVideo: nodeVideo,
        nodeGif: nodeGif,
        nodeAudio: nodeAudio
    };
    
    // Agregar el nuevo nodo al array de nodos
    nodes.push(newNode);
    
    // Crear enlaces para el nuevo nodo
    createLinksForNewNode(nodes.length - 1);
}

// 5. Agregar función para crear enlaces para nuevos nodos
function createLinksForNewNode(nodeIndex) {
    const newNode = nodes[nodeIndex];
    
    // Solo crear enlaces para nodos sensoriales
    if (newNode.nodeType !== "sensory") return;
    
    // Encontrar otros nodos del mismo camino para conectar
    for (let i = 0; i < nodes.length; i++) {
        if (i === nodeIndex) continue; // Omitir a sí mismo
        
        const otherNode = nodes[i];
        if (otherNode.nodeType === "sensory" && otherNode.pathId === newNode.pathId) {
            // Calcular distancia
            const dist = distance2D(
                newNode.x, newNode.y,
                otherNode.x, otherNode.y
            );
            
            // Conectar solo a nodos cercanos con cierta probabilidad
            const maxDist = min(width, height) * 0.5;
            if (dist < maxDist && random() < (1 - dist/maxDist) * 0.6) {
                // Crear enlace con el color del camino
                links.push({
                    source: nodeIndex,
                    target: i,
                    pathId: newNode.pathId,
                    points: generateIntermediatePoints2D(
                        newNode.x, newNode.y,
                        otherNode.x, otherNode.y,
                        floor(random(1, 3))
                    ),
                    velocities: Array(floor(random(1, 3))).fill().map(() => ({
                        x: random(-0.1, 0.1),
                        y: random(-0.1, 0.1)
                    })),
                    color: newNode.color,
                    opacity: random(0.5, 0.8),
                    pulseRate: random(0.001, 0.005),
                    pulseAmount: random(0.1, 0.3)
                });
            }
        }
    }
}

// 6. Modificar la función updateCounterDisplay para mostrar los contadores específicos
// Reemplazar la función updateCounterDisplay completa with:
function updateCounterDisplay() {
    // Si hay un área actual, actualizar su visualización de contador
    if (currentArea) {
        const areaCount = pathCounts[currentArea].count;
        const maxCount = pathCounts[currentArea].maxCount;
        
        // Actualizar las barras de progreso para mostrar el progreso para cada tipo sensorial
        const redCount = pathCounts[currentArea].rojo;
        const greenCount = pathCounts[currentArea].verde;
        const blueCount = pathCounts[currentArea].azul;
        
        // Calcular porcentajes (máximo 100%)
        const redPercentage = Math.min(100, (redCount / (maxCount/3)) * 100);
        const greenPercentage = Math.min(100, (greenCount / (maxCount/3)) * 100);
        const bluePercentage = Math.min(100, (blueCount / (maxCount/3)) * 100);
        
        // Actualizar barras de progreso
        document.getElementById('red-counter').style.width = redPercentage + '%';
        document.getElementById('green-counter').style.width = greenPercentage + '%';
        document.getElementById('blue-counter').style.width = bluePercentage + '%';
        
        // Mostrar el nodo nodriza si el contador alcanza el máximo
        if (areaCount >= maxCount) {
            console.log("Mostrando nodo nodriza para: " + currentArea); // Depuración
            showMotherNode(currentArea);
        } else {
            // Ocultar el nodo nodriza si no hemos alcanzado el máximo
            hideAllMotherNodes();
        }
    } else {
        // Si no hay área seleccionada, mostrar barras vacías
        document.getElementById('red-counter').style.width = '0%';
        document.getElementById('green-counter').style.width = '0%';
        document.getElementById('blue-counter').style.width = '0%';
        
        // Ocultar todos los nodos nodriza
        hideAllMotherNodes();
    }
}

// 7. Modificar la función openExperience para enviar el tipo sensorial más clickeado
// Reemplazar la función openExperience completa with:
function openExperience(areaId) {
    // Determinar qué tipo sensorial fue el más clickeado
    let dominantSensoryType = "rojo"; // Valor predeterminado
    
    if (pathCounts[areaId]) {
        const redCount = pathCounts[areaId].rojo;
        const greenCount = pathCounts[areaId].verde;
        const blueCount = pathCounts[areaId].azul;
        
        // Encontrar el tipo con más clicks
        if (greenCount > redCount && greenCount > blueCount) {
            dominantSensoryType = "verde";
        } else if (blueCount > redCount && blueCount > greenCount) {
            dominantSensoryType = "azul";
        }
    }
    
    // Guardar el área seleccionada y el tipo sensorial dominante en sessionStorage
    sessionStorage.setItem('selectedArea', areaId);
    sessionStorage.setItem('dominantSensoryType', dominantSensoryType);
    
    // Cada área ahora tiene su propia página de experiencia específica
    let experiencePage = 'experiencia.html';
    
    // Redirigir a la página de experiencia específica para cada área
    // Añadir el parámetro de tipo sensorial dominante
    if (areaId === 'aranias') {
        experiencePage = `experiencia-aranias.html?type=${dominantSensoryType}`;
    } else if (areaId === 'feliz') {
        experiencePage = `experiencia-feliz.html?type=${dominantSensoryType}`;
    } else if (areaId === 'triste') {
        experiencePage = `experiencia-triste.html?type=${dominantSensoryType}`;
    }
    
    // Navegar a la página de experiencia
    window.location.href = experiencePage;
}

// 8. Modificar la función navigateToThematicArea para acercarse más al centro
// Reemplazar la función navigateToThematicArea completa with:
function navigateToThematicArea(areaIndex) {
    const area = thematicAreas[areaIndex];
    
    // Calcular vector desde la posición actual hacia el área
    const dirX = area.center.x - targetViewX;
    const dirY = area.center.y - targetViewY;
    
    // Calcular distancia
    const distance = sqrt(dirX * dirX + dirY * dirY);
    
    if (distance > 0) {
        // Mover un porcentaje hacia el área (movimiento gradual)
        // Aumentado el movePercentage para un desplazamiento mayor
        const movePercentage = map(distance, 0, width * 2, 0.3, 0.6); // Aumentado para acercarse más
        const moveDistance = distance * movePercentage;
        
        // Normalizar el vector
        const normX = dirX / distance;
        const normY = dirY / distance;
        
        // Actualizar posición objetivo
        targetViewX += normX * moveDistance;
        targetViewY += normY * moveDistance;
        
        // Acercarse más al centro del área temática basado en el contador
        // Cuantos más clicks, más cerca del centro
        if (currentArea) {
            const zoomFactor = map(pathCounts[currentArea].count, 0, pathCounts[currentArea].maxCount, 0, 0.2);
            targetViewX = lerp(targetViewX, area.center.x, zoomFactor);
            targetViewY = lerp(targetViewY, area.center.y, zoomFactor);
        }
    }
}

// Limpiar recursos al salir de la página
window.addEventListener('beforeunload', function() {
    stopAudio();
});

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
