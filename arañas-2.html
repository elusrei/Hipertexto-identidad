<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arañas - Red de Nodos con GIFs</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #020410; /* Fondo oscuro */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }
        .nodo-container {
            position: absolute;
            border-radius: 5px;
            border: 1px solid #fff;
            background-color: rgba(200, 200, 200, 0.9);
            overflow: hidden;
            z-index: 2;
            cursor: grab;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transition: transform 0.1s ease-out;
        }
        .nodo-container.principal {
            border-width: 2px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }
        .nodo-container.arrastrado {
            cursor: grabbing;
            z-index: 10;
        }
        .iframe-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            background-color: transparent;
        }
        .gif-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .gif-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Asegura que el GIF cubra todo el contenedor */
        }
        
        /* Estilos para el botón de navegación */
        #nav-button-container {
            position: fixed;
            z-index: 1; /* Asegura que esté por encima del canvas pero por detrás de los nodos */
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #nav-button-container a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border: 1px solid white;
            border-radius: 3px;
            display: block; /* Para que el padding funcione bien */
        }
        #nav-button-container a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    
    <div id="nav-button-container">
        <a href="todos-los-nodos.html">Ver Todos los Nodos</a>
    </div>
    
    <script>
        // Variables de configuración de física
        let CONFIG = {
            resistenciaArrastre: 2.8,
            friccion: 0.9,
            fuerzaRetorno: 0.2,
            velocidadMaxima: 17,
            variedadLineas: 0.95,
            tensionLineas: 0.02,       // Reducido aún más
            centralExclusionRadius: 450
        };
        
        // Funciones para el panel de control
        function toggleControlPanel() {
            const panel = document.getElementById('control-panel');
            const boton = document.getElementById('toggle-panel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                boton.textContent = 'Ocultar Controles';
            } else {
                panel.style.display = 'none';
                boton.textContent = 'Mostrar Controles';
            }
        }
        
        function actualizarResistencia(valor) {
            CONFIG.resistenciaArrastre = parseFloat(valor);
            document.getElementById('resistencia-valor').textContent = valor;
        }
        
        function actualizarFriccion(valor) {
            CONFIG.friccion = parseFloat(valor);
            document.getElementById('friccion-valor').textContent = valor;
            // Actualizar fricción en todos los nodos
            for (let nodo of nodos) {
                nodo.friccion = CONFIG.friccion;
            }
        }
        
        function actualizarRetorno(valor) {
            CONFIG.fuerzaRetorno = parseFloat(valor);
            document.getElementById('retorno-valor').textContent = valor;
            // Actualizar fuerza de retorno en todos los nodos
            for (let nodo of nodos) {
                nodo.fuerzaRetorno = CONFIG.fuerzaRetorno;
            }
        }
        
        function actualizarVelocidad(valor) {
            CONFIG.velocidadMaxima = parseFloat(valor);
            document.getElementById('velocidad-valor').textContent = valor;
        }
        
        function actualizarVariedad(valor) {
            CONFIG.variedadLineas = parseFloat(valor);
            document.getElementById('variedad-valor').textContent = valor;
        }
        
        function actualizarTension(valor) {
            CONFIG.tensionLineas = parseFloat(valor);
            document.getElementById('tension-valor').textContent = valor;
        }
        
        function resetearValores() {
            CONFIG.resistenciaArrastre = 2.8;
            CONFIG.friccion = 0.9;
            CONFIG.fuerzaRetorno = 0.2;
            CONFIG.velocidadMaxima = 17;
            CONFIG.variedadLineas = 0.95;
            CONFIG.tensionLineas = 0.02;
            
            document.getElementById('resistencia-arrastre').value = CONFIG.resistenciaArrastre;
            document.getElementById('resistencia-valor').textContent = CONFIG.resistenciaArrastre;
            
            document.getElementById('friccion').value = CONFIG.friccion;
            document.getElementById('friccion-valor').textContent = CONFIG.friccion;
            
            document.getElementById('fuerza-retorno').value = CONFIG.fuerzaRetorno;
            document.getElementById('retorno-valor').textContent = CONFIG.fuerzaRetorno;
            
            document.getElementById('max-velocidad').value = CONFIG.velocidadMaxima;
            document.getElementById('velocidad-valor').textContent = CONFIG.velocidadMaxima;
            
            document.getElementById('variedad-lineas').value = CONFIG.variedadLineas;
            document.getElementById('variedad-valor').textContent = CONFIG.variedadLineas;
            
            document.getElementById('tension-lineas').value = CONFIG.tensionLineas;
            document.getElementById('tension-valor').textContent = CONFIG.tensionLineas;
            
            // Actualizar valores en todos los nodos
            for (let nodo of nodos) {
                nodo.friccion = CONFIG.friccion;
                nodo.fuerzaRetorno = CONFIG.fuerzaRetorno;
            }
        }
        
        function regenerarLineas() {
            // Regenerar tipos de líneas para todas las conexiones
            for (let punto of puntosTelaraña) {
                for (let conexion of punto.conexiones) {
                    // Asignar un nuevo tipo de línea aleatorio
                    let tipoLinea = asignarTipoLinea(
                        punto.x, punto.y, 
                        conexion.x, conexion.y, 
                        punto.esAnclaje || conexion.esAnclaje
                    );
                    
                    // Buscar la conexión en el otro punto y actualizar también
                    let indiceConexion = conexion.conexiones.indexOf(punto);
                    if (indiceConexion !== -1) {
                        if (!punto.tiposLinea) punto.tiposLinea = {};
                        if (!conexion.tiposLinea) conexion.tiposLinea = {};
                        
                        // Guardar el mismo tipo de línea en ambos extremos
                        punto.tiposLinea[conexion.id] = tipoLinea;
                        conexion.tiposLinea[punto.id] = tipoLinea;
                    }
                }
            }
            
            // Regenerar tipos de líneas para nodos
            for (let nodo of nodos) {
                // Conexiones con otros nodos
                for (let conexion of nodo.conexiones) {
                    let tipoLinea = asignarTipoLinea(
                        nodo.x + nodo.ancho/2, nodo.y + nodo.alto/2,
                        conexion.x + conexion.ancho/2, conexion.y + conexion.alto/2,
                        false
                    );
                    
                    if (!nodo.tiposLinea) nodo.tiposLinea = {};
                    nodo.tiposLinea[conexion.id] = tipoLinea;
                }
                
                // Conexiones con puntos de telaraña
                for (let punto of nodo.puntosTelarañaConectados) {
                    let tipoLinea = asignarTipoLinea(
                        nodo.x + nodo.ancho/2, nodo.y + nodo.alto/2,
                        punto.x, punto.y,
                        punto.esAnclaje
                    );
                    
                    if (!nodo.tiposPuntoLinea) nodo.tiposPuntoLinea = {};
                    nodo.tiposPuntoLinea[punto.id] = tipoLinea;
                }
            }
        }
        
        // Clase para los nodos
        class Nodo {
            constructor(x, y, ancho, alto, esPrincipal = false, id) {
                this.x = x;
                this.y = y;
                this.ancho = ancho;
                this.alto = alto;
                this.esPrincipal = esPrincipal;
                this.id = id;
                this.gifIndex = Math.floor(Math.random() * 8) + 1;
                this.elementoDOM = null;
                this.overlayDOM = null;
                
                this.originalX = x;
                this.originalY = y;
                
                // Eliminar parámetros de física y arrastre ya no necesarios
                this.velocidadX = 0;
                this.velocidadY = 0;
                this.friccion = 1; // Establecer fricción a 1 para detener cualquier movimiento residual
                this.fuerzaRetorno = 0;
                
                this.conexiones = [];
                this.puntosTelarañaConectados = [];
                this.arrastrado = false;
                this.afectadoPorArrastre = false;
                
                this.tiposLinea = {};
                this.tiposPuntoLinea = {};
                
                this.crearElementoDOM();
            }
            
            crearElementoDOM() {
                // Crear contenedor del nodo
                this.elementoDOM = document.createElement('div');
                this.elementoDOM.className = 'nodo-container' + (this.esPrincipal ? ' principal' : '');
                this.elementoDOM.id = 'nodo-' + this.id;
                this.elementoDOM.style.width = this.ancho + 'px';
                this.elementoDOM.style.height = this.alto + 'px';
                this.elementoDOM.style.left = this.x + 'px';
                this.elementoDOM.style.top = this.y + 'px';
                
                // Crear contenedor para el GIF
                const gifContainer = document.createElement('div');
                gifContainer.className = 'gif-container';
                
                // Crear elemento de imagen para el GIF
                const gifImage = document.createElement('img');
                gifImage.className = 'gif-image';
                gifImage.src = `arañas/araña-${this.gifIndex}.gif`; // Ruta a los GIFs
                gifImage.alt = `Araña ${this.gifIndex}`;
                
                // Añadir imagen al contenedor
                gifContainer.appendChild(gifImage);
                this.elementoDOM.appendChild(gifContainer);
                
                // Crear overlay para manejar eventos
                this.overlayDOM = document.createElement('div');
                this.overlayDOM.className = 'iframe-overlay';
                this.elementoDOM.appendChild(this.overlayDOM);
                
                // Añadir al DOM
                document.body.appendChild(this.elementoDOM);
            }
            
            // Conectar con un punto de telaraña
            conectarConPuntoTelaraña(punto) {
                if (!this.puntosTelarañaConectados.includes(punto)) {
                    this.puntosTelarañaConectados.push(punto);
                    // También conectar desde el punto al nodo
                    punto.nodosConectados.push(this);
                    
                    // Asignar un tipo de línea para esta conexión
                    if (!this.tiposPuntoLinea) this.tiposPuntoLinea = {};
                    
                    let tipoLinea = asignarTipoLinea(
                        this.x + this.ancho/2, this.y + this.alto/2,
                        punto.x, punto.y,
                        punto.esAnclaje
                    );
                    
                    this.tiposPuntoLinea[punto.id] = tipoLinea;
                }
            }

            // Actualizar posición del elemento DOM
            actualizarDOM() {
                if (this.elementoDOM) {
                    this.elementoDOM.style.left = this.x + 'px';
                    this.elementoDOM.style.top = this.y + 'px';
                }
            }

            // Aplicar física y movimiento
            actualizar() {
                // Mantener posición fija en la posición original
                this.x = this.originalX;
                this.y = this.originalY;
                this.actualizarDOM();
            }

            // Conectar con otro nodo
            conectarCon(otroNodo) {
                if (!this.conexiones.includes(otroNodo)) {
                    this.conexiones.push(otroNodo);
                    
                    // Asignar un tipo de línea para esta conexión
                    if (!this.tiposLinea) this.tiposLinea = {};
                    
                    let tipoLinea = asignarTipoLinea(
                        this.x + this.ancho/2, this.y + this.alto/2,
                        otroNodo.x + otroNodo.ancho/2, otroNodo.y + otroNodo.alto/2,
                        false
                    );
                    
                    this.tiposLinea[otroNodo.id] = tipoLinea;
                }
            }

            // Verificar si el mouse está sobre el nodo
            contienePunto(px, py) {
                return (
                    px > this.x &&
                    px < this.x + this.ancho &&
                    py > this.y &&
                    py < this.y + this.alto
                );
            }
            
            // Calcular posición con resistencia al arrastre
            calcularPosicionConResistencia(mouseX, mouseY, offsetX, offsetY) {
                // Posición deseada según el mouse
                let nuevoX = mouseX - offsetX;
                let nuevoY = mouseY - offsetY;
                
                // Calcular distancia a la posición original
                let dx = nuevoX - this.originalX;
                let dy = nuevoY - this.originalY;
                let distancia = sqrt(dx * dx + dy * dy);
                
                // Aplicar resistencia basada en la distancia
                // La resistencia aumenta exponencialmente con la distancia
                let resistencia = 1 + (distancia * CONFIG.resistenciaArrastre * 0.001);
                
                // Calcular posición con resistencia
                let factorResistencia = 1 / resistencia;
                
                // Posición final = posición original + (desplazamiento deseado / resistencia)
                let finalX = this.originalX + dx * factorResistencia;
                let finalY = this.originalY + dy * factorResistencia;
                
                return { x: finalX, y: finalY };
            }
            
            // Registrar la velocidad al arrastrar
            registrarVelocidad(nuevoX, nuevoY) {
                this.velocidadX = nuevoX - this.x;
                this.velocidadY = nuevoY - this.y;
                this.x = nuevoX;
                this.y = nuevoY;
                this.actualizarDOM();
            }
            
            // Afectar a los nodos cercanos cuando este nodo se mueve
            afectarCercanos(nodos, velocidadX, velocidadY) {
                for (let nodo of nodos) {
                    if (nodo !== this && !nodo.arrastrado) {
                        // Calcular distancia
                        let dx = nodo.x - this.x;
                        let dy = nodo.y - this.y;
                        let distancia = sqrt(dx * dx + dy * dy);
                        
                        // Radio de influencia - aumentado para afectar a más nodos
                        let radioInfluencia = (this.ancho + this.alto + nodo.ancho + nodo.alto);
                        
                        if (distancia < radioInfluencia) {
                            // Marcar el nodo como afectado por arrastre
                            nodo.afectadoPorArrastre = true;
                            
                            // Calcular fuerza inversamente proporcional a la distancia
                            let factorFuerza = map(distancia, 0, radioInfluencia, 0.8, 0.1);
                            
                            // Mover en la misma dirección que el nodo arrastrado
                            nodo.x += velocidadX * factorFuerza;
                            nodo.y += velocidadY * factorFuerza;
                            
                            // Actualizar el DOM
                            nodo.actualizarDOM();
                        } else {
                            // Si está fuera del radio de influencia, ya no está afectado
                            nodo.afectadoPorArrastre = false;
                        }
                    }
                }
            }
            
            // Liberar todos los nodos afectados
            liberarNodosAfectados(nodos) {
                for (let nodo of nodos) {
                    if (nodo.afectadoPorArrastre) {
                        // Calcular velocidad de retorno basada en la distancia a la posición original
                        let dx = nodo.originalX - nodo.x;
                        let dy = nodo.originalY - nodo.y;
                        let distancia = sqrt(dx * dx + dy * dy);
                        
                        // Aplicar una velocidad proporcional a la distancia, pero controlada
                        // Velocidad más suave para evitar movimientos bruscos
                        let factorVelocidad = map(distancia, 0, 100, 0.05, 0.2);
                        nodo.velocidadX = dx * factorVelocidad;
                        nodo.velocidadY = dy * factorVelocidad;
                        
                        // Ya no está afectado por arrastre
                        nodo.afectadoPorArrastre = false;
                    }
                }
            }
            
            // Dibujar conexiones con otros nodos y puntos de telaraña
            dibujarConexiones() {
                // Eliminar dibujado de conexiones con otros nodos
                // for (let conexion of this.conexiones) {
                //     // Puntos de inicio y fin
                //     let x1 = this.x + this.ancho / 2;
                //     let y1 = this.y + this.alto / 2;
                //     let x2 = conexion.x + conexion.ancho / 2;
                //     let y2 = conexion.y + conexion.alto / 2;
                    
                //     // Obtener el tipo de línea para esta conexión
                //     let tipoLinea = this.tiposLinea && this.tiposLinea[conexion.id] 
                //         ? this.tiposLinea[conexion.id] 
                //         : { tipo: 'recta', tension: 0.5 };
                    
                //     // Dibujar línea según su tipo
                //     dibujarLineaOrganica(x1, y1, x2, y2, 150, 1.5, tipoLinea);
                // }
                
                // Eliminar dibujado de conexiones con puntos de telaraña
                // for (let punto of this.puntosTelarañaConectados) {
                //     let x1 = this.x + this.ancho / 2;
                //     let y1 = this.y + this.alto / 2;
                    
                //     // Obtener el tipo de línea para esta conexión
                //     let tipoLinea = this.tiposPuntoLinea && this.tiposPuntoLinea[punto.id] 
                //         ? this.tiposPuntoLinea[punto.id] 
                //         : { tipo: 'recta', tension: 0.5 };
                    
                //     // Calcular opacidad basada en la distancia
                //     let distancia = dist(x1, y1, punto.x, punto.y);
                //     let alpha = map(distancia, 0, width/2, 150, 50);
                    
                //     // Dibujar línea según su tipo
                //     dibujarLineaOrganica(x1, y1, punto.x, punto.y, alpha, 0.8, tipoLinea);
                // }
            }
            
            // Eliminar el elemento DOM
            destruir() {
                if (this.elementoDOM && this.elementoDOM.parentNode) {
                    this.elementoDOM.parentNode.removeChild(this.elementoDOM);
                }
            }
            
            // Obtener el centro del nodo
            getCentro() {
                return {
                    x: this.x + this.ancho / 2,
                    y: this.y + this.alto / 2
                };
            }
        }

        // Clase para los puntos de la telaraña
        class PuntoTelaraña {
            constructor(x, y, esAnclaje = false) {
                this.x = x;
                this.y = y;
                this.esAnclaje = esAnclaje;
                this.conexiones = [];
                this.nodosConectados = [];
                this.id = 'punto-' + Math.floor(Math.random() * 1000000);
                this.tiposLinea = {};
                this.originalX = x;
                this.originalY = y;
                
                // Eliminar completamente el movimiento
                this.amplitud = 0;
                this.frecuencia = 0;
                this.fase = 0;
                
                // Eliminar la reactividad al mouse
                this.influenciaMaxima = 0;
                this.fuerzaRepulsion = 0;
            }
            
            conectarCon(otroPunto) {
                if (!this.conexiones.includes(otroPunto)) {
                    this.conexiones.push(otroPunto);
                    
                    // Asignar un tipo de línea para esta conexión
                    let tipoLinea = asignarTipoLinea(
                        this.x, this.y, 
                        otroPunto.x, otroPunto.y, 
                        this.esAnclaje || otroPunto.esAnclaje
                    );
                    
                    this.tiposLinea[otroPunto.id] = tipoLinea;
                }
            }
            
            actualizar(mouseX, mouseY) {
                // Mantener las posiciones fijas
                this.x = this.originalX;
                this.y = this.originalY;
            }
            
            dibujarConexiones(mouseX, mouseY) {
                for (let punto of this.conexiones) {
                    // Calcular distancia para determinar opacidad
                    let d = dist(this.x, this.y, punto.x, punto.y);
                    let maxDist = min(width, height) * 0.4;
                    let alpha = map(d, 0, maxDist, 30, 10);
                    
                    // Las líneas en los bordes son más visibles
                    if (this.esAnclaje || punto.esAnclaje) {
                        alpha = map(d, 0, maxDist, 60, 20);
                    }
                    
                    // Aumentar opacidad si el mouse está cerca de la línea
                    let distanciaLineaMouse = distPuntoLinea(
                        mouseX, mouseY,
                        this.x, this.y,
                        punto.x, punto.y
                    );
                    
                    if (distanciaLineaMouse < 50) {
                        // Aumentar opacidad cuando el mouse está cerca
                        let factorCercania = map(distanciaLineaMouse, 0, 50, 3, 1);
                        alpha = min(255, alpha * factorCercania);
                    }
                    
                    // Obtener el tipo de línea para esta conexión
                    let tipoLinea = this.tiposLinea && this.tiposLinea[punto.id] 
                        ? this.tiposLinea[punto.id] 
                        : { tipo: 'recta', tension: 0.5 };
                    
                    // Dibujar línea según su tipo
                    dibujarLineaOrganica(this.x, this.y, punto.x, punto.y, alpha, 0.5, tipoLinea);
                }
            }
        }
        
        // Función para asignar un tipo de línea basado en la distancia y posición
        function asignarTipoLinea(x1, y1, x2, y2, esAnclaje) {
            let distancia = dist(x1, y1, x2, y2);
            let tipoLinea = {};
            
            let randomValue = random();
            // variedadAjustada ya no se usa para la probabilidad, solo para otros posibles ajustes futuros
            // let variedadAjustada = CONFIG.variedadLineas;
            
            // if (esAnclaje) {
            //     variedadAjustada *= 0.7; 
            // }
            
            // Ajustamos las probabilidades y parámetros para asegurar más curvatura y variedad
            if (randomValue < 0.001) {  // Probabilidad casi cero de líneas rectas
                tipoLinea.tipo = 'recta';
                // Aunque sea recta, aseguramos una mínima curvatura con la tensión
                tipoLinea.tension = random(0.3, 0.5) * CONFIG.tensionLineas; 
            } else if (randomValue < 0.2) {  // Ajustar probabilidad de caída simple
                tipoLinea.tipo = 'caida-simple';
                tipoLinea.tension = random(0.08, 0.15) * CONFIG.tensionLineas; 
                tipoLinea.magnitud = random(0.25, 0.35) * (1 - CONFIG.tensionLineas); 
            } else if (randomValue < 0.55) {  // Ajustar probabilidad de caída pronunciada
                tipoLinea.tipo = 'caida-pronunciada';
                tipoLinea.tension = random(0.03, 0.07) * CONFIG.tensionLineas; 
                tipoLinea.magnitud = random(0.45, 0.6) * (1 - CONFIG.tensionLineas); 
            } else {  // Aumentar probabilidad de líneas rotas y ajustar rango de rotura y magnitud
                tipoLinea.tipo = 'rota';
                tipoLinea.tension = random(0.001, 0.02) * CONFIG.tensionLineas; 
                tipoLinea.magnitud = random(0.6, 0.8) * (1 - CONFIG.tensionLineas); 
                tipoLinea.rotura = random(0.4, 0.6); 
            }
            
            return tipoLinea;
        }
        
        // Función para dibujar una línea orgánica según su tipo
        function dibujarLineaOrganica(x1, y1, x2, y2, alpha = 150, grosor = 0.5, tipoLinea) {
            stroke(255, 255, 255, alpha);
            strokeWeight(grosor);
            noFill();
            
            if (!tipoLinea) {
                tipoLinea = { tipo: 'recta', tension: 0.5 };
            }
            
            let dx = x2 - x1;
            let dy = y2 - y1;
            let distancia = sqrt(dx * dx + dy * dy);
            
            // Evitar división por cero si los puntos son idénticos o muy cercanos
            if (distancia < 1) { 
                line(x1, y1, x2, y2); // Dibujar una línea recta muy corta
                return;
            }
            
            let perpX = -dy / distancia;
            let perpY = dx / distancia;
            
            switch (tipoLinea.tipo) {
                case 'recta':
                    // Curvatura sutil pero garantizada para líneas casi rectas
                    let desviacionRecta = (1 - tipoLinea.tension) * 40; 
                    let ctrlXRecta = (x1 + x2) / 2 + perpX * desviacionRecta;
                    let ctrlYRecta = (y1 + y2) / 2 + perpY * desviacionRecta;
                    bezier(x1, y1, 
                           x1 * 0.2 + ctrlXRecta * 0.8, y1 * 0.2 + ctrlYRecta * 0.8, 
                           x2 * 0.2 + ctrlXRecta * 0.8, y2 * 0.2 + ctrlYRecta * 0.8, 
                           x2, y2);
                    break;
                    
                case 'caida-simple':
                    let magnitudCaidaSimple = tipoLinea.magnitud * distancia;
                    let midXSimple = (x1 + x2) / 2;
                    let midYSimple = (y1 + y2) / 2 + magnitudCaidaSimple;
                    
                    // Curva suave hacia abajo, ajustando puntos de control para mejor forma
                    // Puntos de control más abajo y ligeramente hacia afuera
                    let c1xSimple = x1 + (midXSimple - x1) * 0.3 - perpX * distancia * 0.1;
                    let c1ySimple = y1 + (midYSimple - y1) * 0.7 + perpY * distancia * 0.1; // Más hacia abajo
                    let c2xSimple = x2 + (midXSimple - x2) * 0.3 - perpX * distancia * 0.1;
                    let c2ySimple = y2 + (midYSimple - y2) * 0.7 + perpY * distancia * 0.1; // Más hacia abajo
                    
                    bezier(x1, y1, c1xSimple, c1ySimple, c2xSimple, c2ySimple, x2, y2);
                    break;
                    
                case 'caida-pronunciada':
                    let magnitudCaidaPronunciada = tipoLinea.magnitud * distancia;
                    let midXPronunciada = (x1 + x2) / 2;
                    let midYPronunciada = (y1 + y2) / 2 + magnitudCaidaPronunciada;
                    
                    // Caída más pronunciada y suave, puntos de control bien abajo y separados
                    let c1xPronunciada = x1 + (midXPronunciada - x1) * 0.1 - perpX * distancia * 0.2; // Más cerca de x1 y hacia afuera
                    let c1yPronunciada = y1 + (midYPronunciada - y1) * 0.9 + perpY * distancia * 0.2; // Significativamente más abajo
                    let c2xPronunciada = x2 + (midXPronunciada - x2) * 0.1 - perpX * distancia * 0.2; // Más cerca de x2 y hacia afuera
                    let c2yPronunciada = y2 + (midYPronunciada - y2) * 0.9 + perpY * distancia * 0.2; // Significativamente más abajo
                    
                    bezier(x1, y1, c1xPronunciada, c1yPronunciada, c2xPronunciada, c2yPronunciada, x2, y2);
                    break;
                    
                case 'rota':
                    let puntoRoturaX = x1 + dx * tipoLinea.rotura;
                    let puntoRoturaY = y1 + dy * tipoLinea.rotura;
                    
                    let puntoFinalX = puntoRoturaX;
                    let puntoFinalY = puntoRoturaY + distancia * tipoLinea.magnitud;
                    
                    // Primera parte (conectada) - curva suave hacia el punto de rotura
                    // Puntos de control cerca de los extremos y punto de rotura
                    let c1xRota1 = x1 + (puntoRoturaX - x1) * 0.2; 
                    let c1yRota1 = y1 + (puntoRoturaY - y1) * 0.2;
                    let c2xRota1 = x1 + (puntoRoturaX - x1) * 0.8; 
                    let c2yRota1 = y1 + (puntoRoturaY - y1) * 0.8;
                    bezier(x1, y1, c1xRota1, c1yRota1, c2xRota1, c2yRota1, puntoRoturaX, puntoRoturaY);
                    
                    // Parte colgante - curva suave y natural hacia abajo
                    // Ajustar puntos de control para una caída más pronunciada y forma orgánica
                    // Puntos de control más abajo y ligeramente curvados
                    let c1xRota2 = puntoRoturaX + (puntoFinalX - puntoRoturaX) * 0.1 + perpX * distancia * 0.05; // Control horizontal cerca de la rotura, ligera desviación
                    let c1yRota2 = puntoRoturaY + (puntoFinalY - puntoRoturaY) * 0.2 + perpY * distancia * 0.05; // Control vertical iniciando caída suave, ligera desviación
                    let c2xRota2 = puntoRoturaX + (puntoFinalX - puntoRoturaX) * 0.9 + perpX * distancia * 0.05; // Control horizontal cerca del final, ligera desviación
                    let c2yRota2 = puntoRoturaY + (puntoFinalY - puntoRoturaY) * 0.5 + perpY * distancia * 0.05; // Control vertical terminando caída, ligera desviación
                    bezier(puntoRoturaX, puntoRoturaY, c1xRota2, c1yRota2, c2xRota2, c2yRota2, puntoFinalX, puntoFinalY);
                    break;
                    
                default:
                    line(x1, y1, x2, y2);
            }
        }
        
        // Función para calcular la distancia de un punto a una línea
        function distPuntoLinea(px, py, x1, y1, x2, y2) {
            // Longitud de la línea al cuadrado
            let l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            
            if (l2 === 0) return dist(px, py, x1, y1); // La línea es un punto
            
            // Proyección del punto en la línea, parametrizada como 0 <= t <= 1
            let t = max(0, min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2));
            
            // Punto más cercano en la línea
            let proyeccionX = x1 + t * (x2 - x1);
            let proyeccionY = y1 + t * (y2 - y1);
            
            // Distancia entre el punto y su proyección
            return dist(px, py, proyeccionX, proyeccionY);
        }

        // Variables globales
        let nodos = [];
        let nodoPrincipal;
        let nodoArrastrado = null;
        let offsetX, offsetY;
        let cantidadNodos = 7;
        let ultimoX, ultimoY;
        let centroX, centroY;
        let canvas;
        
        // Variables para la telaraña
        let puntosTelaraña = [];
        let cantidadPuntosAnclaje = 60;
        let cantidadPuntosInteriores = 250;
        
        // Variables para el botón de navegación flotante
        let navButtonContainer;

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight);
            canvas.style('pointer-events', 'none');
            
            centroX = width / 2;
            centroY = height / 2;
            
            crearTelaraña();
            
            // Crear solo el nodo principal en el centro
            let anchoPrincipal = min(width * 0.45, 550);
            let altoPrincipal = min(height * 0.45, 350);
            nodoPrincipal = new Nodo(
                centroX - anchoPrincipal/2, 
                centroY - altoPrincipal/2, 
                anchoPrincipal, 
                altoPrincipal,
                true,
                'principal'
            );
            nodos.push(nodoPrincipal);
            
            // Conectar puntos de telaraña con el nodo principal
            conectarTelarañaConNodos();
            
            // Configurar eventos de arrastre
            configurarEventosArrastre();

            // Posicionar el botón de navegación debajo del nodo principal
            navButtonContainer = document.getElementById('nav-button-container');
            navButtonContainer.style.position = 'absolute';
            navButtonContainer.style.left = (centroX - navButtonContainer.offsetWidth/2) + 'px';
            navButtonContainer.style.top = (centroY + altoPrincipal/2 + 20) + 'px';
            navButtonContainer.style.zIndex = '1000';
        }
        
        // Función para conectar puntos de telaraña con nodos
        function conectarTelarañaConNodos() {
            // Para cada nodo, conectar con algunos puntos de telaraña cercanos
            for (let nodo of nodos) {
                let centro = nodo.getCentro();
                let puntosConectables = [];
                
                // Encontrar puntos de telaraña cercanos
                for (let punto of puntosTelaraña) {
                    let distancia = dist(centro.x, centro.y, punto.x, punto.y);
                    let maxDist = nodo.esPrincipal ? width * 0.4 : width * 0.25;
                    
                    if (distancia < maxDist) {
                        puntosConectables.push({
                            punto: punto,
                            distancia: distancia
                        });
                    }
                }
                
                // Ordenar por distancia (más cercanos primero)
                puntosConectables.sort((a, b) => a.distancia - b.distancia);
                
                // Conectar con algunos puntos (más para el nodo principal)
                let cantidadConexiones = nodo.esPrincipal ? 
                    floor(random(15, 25)) : 
                    floor(random(5, 10));
                
                // Limitar a la cantidad disponible
                cantidadConexiones = min(cantidadConexiones, puntosConectables.length);
                
                // Conectar con puntos aleatorios entre los cercanos
                for (let i = 0; i < cantidadConexiones; i++) {
                    let indice = floor(random(puntosConectables.length));
                    let puntoInfo = puntosConectables.splice(indice, 1)[0];
                    nodo.conectarConPuntoTelaraña(puntoInfo.punto);
                }
            }
        }
        
        function configurarEventosArrastre() {
            // Para cada nodo, configurar eventos de arrastre
            for (let nodo of nodos) {
                if (nodo.overlayDOM) {
                    // Comentar el evento mouseenter para deshabilitar el inicio del arrastre
                    // nodo.overlayDOM.addEventListener('mouseenter', (e) => {
                    //     if (!nodoArrastrado) {
                    //         nodoArrastrado = nodo;
                    //         nodoArrastrado.arrastrado = true;
                    //         nodoArrastrado.elementoDOM.classList.add('arrastrado');
                    //         offsetX = e.clientX - (nodo.x + nodo.ancho / 2) + nodo.ancho / 2;
                    //         offsetY = e.clientY - (nodo.y + nodo.alto / 2) + nodo.alto / 2;
                    //         ultimoX = e.clientX;
                    //         ultimoY = e.clientY;
                    //         e.preventDefault();
                    //     }
                    // });
                }
            }
            
            // Comentar eventos globales para mousemove y mouseup
            // document.addEventListener('mousemove', (e) => {
            //     if (nodoArrastrado) {
            //         let posicion = nodoArrastrado.calcularPosicionConResistencia(
            //             e.clientX, e.clientY, offsetX, offsetY
            //         );
                    
            //         let velocidadMouseX = e.clientX - ultimoX;
            //         let velocidadMouseY = e.clientY - ultimoY;
            //         let velocidadMouse = sqrt(velocidadMouseX * velocidadMouseX + velocidadMouseY * velocidadMouseY);
                    
            //         let distanciaOrigen = dist(nodoArrastrado.x, nodoArrastrado.y, nodoArrastrado.originalX, nodoArrastrado.originalY);
                    
            //         let distanciaMaximaArrastre = min(width, height) * 0.4;
            //         let velocidadMaximaMouse = 450;
                    
            //         if (distanciaOrigen > distanciaMaximaArrastre || velocidadMouse > velocidadMaximaMouse) {
            //             liberarArrastre();
            //             return;
            //         }
                    
            //         let velocidadNodoX = posicion.x - nodoArrastrado.x;
            //         let velocidadNodoY = posicion.y - nodoArrastrado.y;
                    
            //         nodoArrastrado.registrarVelocidad(posicion.x, posicion.y);
            //         nodoArrastrado.afectarCercanos(nodos, velocidadNodoX, velocidadNodoY);
                    
            //         ultimoX = e.clientX;
            //         ultimoY = e.clientY;
                    
            //         e.preventDefault();
            //     }
            // });
            
            // document.addEventListener('mouseup', (e) => {
            //     // El arrastre se detiene por distancia o velocidad del mouse
            // });
            
            // Comentar la función liberarArrastre ya que no se usará
            // function liberarArrastre() {
            //     if (nodoArrastrado) {
            //         let velocidadFinalX = (ultimoX - nodoArrastrado.x) * 0.5;
            //         let velocidadFinalY = (ultimoY - nodoArrastrado.y) * 0.5;
                    
            //         velocidadFinalX = constrain(velocidadFinalX, -CONFIG.velocidadMaxima, CONFIG.velocidadMaxima);
            //         velocidadFinalY = constrain(velocidadFinalY, -CONFIG.velocidadMaxima, CONFIG.velocidadMaxima);
                    
            //         nodoArrastrado.velocidadX = velocidadFinalX;
            //         nodoArrastrado.velocidadY = velocidadFinalY;
                    
            //         nodoArrastrado.liberarNodosAfectados(nodos);
                    
            //         nodoArrastrado.arrastrado = false;
            //         nodoArrastrado.elementoDOM.classList.remove('arrastrado');
            //         nodoArrastrado = null;
            //     }
            // }
        }
        
        function crearTelaraña() {
            puntosTelaraña = [];
            
            // Crear puntos de anclaje en los bordes
            for (let i = 0; i < cantidadPuntosAnclaje; i++) {
                let punto;
                
                if (i < cantidadPuntosAnclaje / 4) {
                    // Borde superior
                    punto = new PuntoTelaraña(
                        map(i, 0, cantidadPuntosAnclaje / 4 - 1, 0, width),
                        0,
                        true
                    );
                } else if (i < cantidadPuntosAnclaje / 2) {
                    // Borde derecho
                    punto = new PuntoTelaraña(
                        width,
                        map(i, cantidadPuntosAnclaje / 4, cantidadPuntosAnclaje / 2 - 1, 0, height),
                        true
                    );
                } else if (i < 3 * cantidadPuntosAnclaje / 4) {
                    // Borde inferior
                    punto = new PuntoTelaraña(
                        map(i, cantidadPuntosAnclaje / 2, 3 * cantidadPuntosAnclaje / 4 - 1, width, 0),
                        height,
                        true
                    );
                } else {
                    // Borde izquierdo
                    punto = new PuntoTelaraña(
                        0,
                        map(i, 3 * cantidadPuntosAnclaje / 4, cantidadPuntosAnclaje - 1, height, 0),
                        true
                    );
                }
                
                puntosTelaraña.push(punto);
            }
            
            // Crear puntos interiores
            for (let i = 0; i < cantidadPuntosInteriores; i++) {
                // Distribuir más puntos en los márgenes y menos en el centro
                let angulo = random(TWO_PI);
                let radio;
                
                if (random() < 0.7) {
                    // 70% de los puntos más cerca de los bordes
                    radio = random(0.5, 0.95) * max(width, height) / 2;
                } else {
                    // 30% más cerca del centro
                    radio = random(0.1, 0.5) * max(width, height) / 2;
                }
                
                let x = centroX + cos(angulo) * radio;
                let y = centroY + sin(angulo) * radio;
                
                puntosTelaraña.push(new PuntoTelaraña(x, y, false));
            }
            
            // Conectar puntos de la telaraña
            for (let i = 0; i < puntosTelaraña.length; i++) {
                // Conectar con puntos cercanos
                for (let j = i + 1; j < puntosTelaraña.length; j++) {
                    let d = dist(
                        puntosTelaraña[i].x, puntosTelaraña[i].y,
                        puntosTelaraña[j].x, puntosTelaraña[j].y
                    );
                    
                    let maxDist = min(width, height) * 0.3;
                    
                    // Conectar si están lo suficientemente cerca
                    if (d < maxDist) {
                        // Probabilidad de conexión inversamente proporcional a la distancia
                        let probabilidad = map(d, 0, maxDist, 1, 0.3);
                        
                        // Más conexiones para puntos de anclaje
                        if (puntosTelaraña[i].esAnclaje || puntosTelaraña[j].esAnclaje) {
                            probabilidad *= 1.8;
                        }
                        
                        if (random() < probabilidad) {
                            puntosTelaraña[i].conectarCon(puntosTelaraña[j]);
                            puntosTelaraña[j].conectarCon(puntosTelaraña[i]);
                        }
                    }
                }
                
                // Asegurar que todos los puntos tengan al menos una conexión
                if (puntosTelaraña[i].conexiones.length === 0) {
                    let puntoMasCercano = null;
                    let distanciaMinima = Infinity;
                    
                    for (let j = 0; j < puntosTelaraña.length; j++) {
                        if (i !== j) {
                            let d = dist(
                                puntosTelaraña[i].x, puntosTelaraña[i].y,
                                puntosTelaraña[j].x, puntosTelaraña[j].y
                            );
                            
                            if (d < distanciaMinima) {
                                distanciaMinima = d;
                                puntoMasCercano = puntosTelaraña[j];
                            }
                        }
                    }
                    
                    if (puntoMasCercano) {
                        puntosTelaraña[i].conectarCon(puntoMasCercano);
                        puntoMasCercano.conectarCon(puntosTelaraña[i]);
                    }
                }
                
                // Añadir más conexiones adicionales para aumentar la densidad
                if (!puntosTelaraña[i].esAnclaje && random() < 0.85) {
                    let conexionesAdicionales = floor(random(2, 5));
                    let intentos = 0;
                    
                    while (puntosTelaraña[i].conexiones.length < conexionesAdicionales + 1 && intentos < 15) {
                        let indiceAleatorio = floor(random(puntosTelaraña.length));
                        
                        if (indiceAleatorio !== i && !puntosTelaraña[i].conexiones.includes(puntosTelaraña[indiceAleatorio])) {
                            let d = dist(
                                puntosTelaraña[i].x, puntosTelaraña[i].y,
                                puntosTelaraña[indiceAleatorio].x, puntosTelaraña[indiceAleatorio].y
                            );
                            
                            if (d < min(width, height) * 0.35) {
                                puntosTelaraña[i].conectarCon(puntosTelaraña[indiceAleatorio]);
                                puntosTelaraña[indiceAleatorio].conectarCon(puntosTelaraña[i]);
                            }
                        }
                        
                        intentos++;
                    }
                }
            }
            
            // Añadir conexiones cruzadas adicionales para aumentar aún más la densidad
            let conexionesAdicionales = floor(cantidadPuntosInteriores * 0.3);
            for (let i = 0; i < conexionesAdicionales; i++) {
                let indice1 = floor(random(puntosTelaraña.length));
                let indice2 = floor(random(puntosTelaraña.length));
                
                if (indice1 !== indice2 && !puntosTelaraña[indice1].conexiones.includes(puntosTelaraña[indice2])) {
                    let d = dist(
                        puntosTelaraña[indice1].x, puntosTelaraña[indice1].y,
                        puntosTelaraña[indice2].x, puntosTelaraña[indice2].y
                    );
                    
                    if (d < min(width, height) * 0.4) {
                        puntosTelaraña[indice1].conectarCon(puntosTelaraña[indice2]);
                        puntosTelaraña[indice2].conectarCon(puntosTelaraña[indice1]);
                    }
                }
            }
        }

        function draw() {
            clear();
            
            // Solo dibujar las conexiones, sin actualizar nada
            for (let punto of puntosTelaraña) {
                punto.actualizar(mouseX, mouseY);
                punto.dibujarConexiones(mouseX, mouseY);
            }
            
            for (let nodo of nodos) {
                nodo.actualizar();
                nodo.dibujarConexiones();
            }
        }

        // Ajustar el tamaño del canvas y recentralizar cuando cambia el tamaño de la ventana
        function windowResized() {
            // Limpiar nodos existentes
            for (let nodo of nodos) {
                nodo.destruir();
            }
            nodos = [];
            
            // Redimensionar canvas
            resizeCanvas(windowWidth, windowHeight);
            
            // Actualizar el centro
            centroX = width / 2;
            centroY = height / 2;
            
            // Recrear todo
            setup();
        }

        // Agregar un nuevo nodo al hacer doble clic
        function doubleClicked() {
            let ancho = min(width, height) * random(0.15, 0.22);
            
            let relacionAspecto;
            let tipoNodo = random();
            
            if (tipoNodo < 0.5) {
                relacionAspecto = random(1.2, 1.6);
            } else if (tipoNodo < 0.8) {
                relacionAspecto = random(0.9, 1.1);
            } else {
                relacionAspecto = random(0.6, 0.8);
            }
            
            let alto = ancho / relacionAspecto;
            
            let nuevoNodo = new Nodo(
                mouseX - ancho/2, 
                mouseY - alto/2, 
                ancho, 
                alto,
                false,
                'nuevo-' + nodos.length
            );
            
            nuevoNodo.originalX = nuevoNodo.x;
            nuevoNodo.originalY = nuevoNodo.y;
            
            // Conectar con el nodo principal
            nuevoNodo.conectarCon(nodoPrincipal);
            nodoPrincipal.conectarCon(nuevoNodo);
            
            // Conectar con otro nodo aleatorio
            if (nodos.length > 1) {
                let indiceAleatorio;
                do {
                    indiceAleatorio = floor(random(nodos.length));
                } while (nodos[indiceAleatorio] === nodoPrincipal);
                
                nuevoNodo.conectarCon(nodos[indiceAleatorio]);
            }
            
            // Conectar con puntos de telaraña cercanos
            let centro = nuevoNodo.getCentro();
            let puntosConectables = [];
            
            for (let punto of puntosTelaraña) {
                let distancia = dist(centro.x, centro.y, punto.x, punto.y);
                if (distancia < width * 0.25) {
                    puntosConectables.push({
                        punto: punto,
                        distancia: distancia
                    });
                }
            }
            
            puntosConectables.sort((a, b) => a.distancia - b.distancia);
            
            let cantidadConexiones = floor(random(5, 10));
            cantidadConexiones = min(cantidadConexiones, puntosConectables.length);
            
            for (let i = 0; i < cantidadConexiones; i++) {
                let indice = floor(random(puntosConectables.length));
                let puntoInfo = puntosConectables.splice(indice, 1)[0];
                nuevoNodo.conectarConPuntoTelaraña(puntoInfo.punto);
            }
            
            // Configurar eventos de arrastre
            if (nuevoNodo.overlayDOM) {
                nuevoNodo.overlayDOM.addEventListener('mousedown', (e) => {
                    nodoArrastrado = nuevoNodo;
                    nodoArrastrado.arrastrado = true;
                    nuevoNodo.elementoDOM.classList.add('arrastrado');
                    offsetX = e.clientX - nuevoNodo.x;
                    offsetY = e.clientY - nuevoNodo.y;
                    ultimoX = e.clientX;
                    ultimoY = e.clientY;
                    e.preventDefault();
                });
            }
            
            nodos.push(nuevoNodo);
        }
    </script>
</body>
</html>
